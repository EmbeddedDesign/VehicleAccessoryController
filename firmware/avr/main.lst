   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	uart_putchar:
  12               	.LFB12:
  13               		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****  * Name: Vehicle Accessory Controller
   3:main.c        ****  * Author: Noctivore
   4:main.c        ****  * Description: AVR-C application code for Vehicle Accessory Controller
   5:main.c        ****  * Version 1.0
   6:main.c        ****  * Date: 8 July 2020
   7:main.c        ****  */
   8:main.c        **** 
   9:main.c        ****  // Include headers
  10:main.c        **** #include <avr/power.h>
  11:main.c        **** #include <avr/sleep.h>
  12:main.c        **** #include <avr/interrupt.h>
  13:main.c        **** #include <avr/pgmspace.h>
  14:main.c        **** #include <util/delay.h>
  15:main.c        **** #include <stdio.h>
  16:main.c        **** #include "main.h"
  17:main.c        **** 
  18:main.c        **** // Serial definitions
  19:main.c        **** #ifndef F_CPU
  20:main.c        **** #define F_CPU 16000000UL
  21:main.c        **** #endif
  22:main.c        **** 
  23:main.c        **** #ifndef BAUD
  24:main.c        **** #define BAUD 115200
  25:main.c        **** #endif
  26:main.c        **** #include <util/setbaud.h>
  27:main.c        **** 
  28:main.c        **** #define SERIAL_DELAY 1
  29:main.c        **** 
  30:main.c        **** // Pin definitions
  31:main.c        **** #define PARK_FRONT   14 // A0
  32:main.c        **** #define PARK_RIGHT   15 // A1
  33:main.c        **** #define PARK_LEFT    16 // A2
  34:main.c        **** #define PARK_REAR    17 // A3
  35:main.c        **** #define PARK_STATUS  18
  36:main.c        **** #define POWER_STATUS 13
  37:main.c        **** #define ACC          2
  38:main.c        **** 
  39:main.c        **** // String constants stored in flash
  40:main.c        **** const __flash char status[] = "System Status: OK";
  41:main.c        **** const __flash char enablePark[] = "Park Mode: Enabled";
  42:main.c        **** const __flash char disablePark[] = "Park Mode: Disabled";
  43:main.c        **** 
  44:main.c        **** // URART initialization function
  45:main.c        **** void uart_init(void) {
  46:main.c        ****     UBRR0H = UBRRH_VALUE;
  47:main.c        ****     UBRR0L = UBRRL_VALUE;
  48:main.c        ****     
  49:main.c        **** #if USE_2X
  50:main.c        ****     UCSR0A |= _BV(U2X0);
  51:main.c        **** #else
  52:main.c        ****     UCSR0A &= ~(_BV(U2X0));
  53:main.c        **** #endif
  54:main.c        **** 
  55:main.c        ****     UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); // 8-bit data
  56:main.c        ****     UCSR0B = _BV(RXEN0) | _BV(TXEN0);   // Enable RX and TX
  57:main.c        **** }
  58:main.c        **** 
  59:main.c        **** // UART putchar function
  60:main.c        **** static int uart_putchar(char c, FILE *stream) {
  14               		.loc 1 60 0
  15               		.cfi_startproc
  16               	.LVL0:
  17 0000 CF93      		push r28
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 28, -2
  21               	/* prologue: function */
  22               	/* frame size = 0 */
  23               	/* stack size = 1 */
  24               	.L__stack_usage = 1
  25 0002 C82F      		mov r28,r24
  61:main.c        ****     if (c == '\n') {
  26               		.loc 1 61 0
  27 0004 8A30      		cpi r24,lo8(10)
  28 0006 01F4      		brne .L3
  62:main.c        ****         uart_putchar('\r', stream);
  29               		.loc 1 62 0
  30 0008 8DE0      		ldi r24,lo8(13)
  31               	.LVL1:
  32 000a 0E94 0000 		call uart_putchar
  33               	.LVL2:
  34               	.L3:
  63:main.c        ****     }
  64:main.c        ****     loop_until_bit_is_set(UCSR0A, UDRE0);
  35               		.loc 1 64 0 discriminator 1
  36 000e 8091 C000 		lds r24,192
  37 0012 85FF      		sbrs r24,5
  38 0014 00C0      		rjmp .L3
  65:main.c        ****     UDR0 = c;
  39               		.loc 1 65 0
  40 0016 C093 C600 		sts 198,r28
  66:main.c        ****     return 0;
  67:main.c        **** }
  41               		.loc 1 67 0
  42 001a 80E0      		ldi r24,0
  43 001c 90E0      		ldi r25,0
  44               	/* epilogue start */
  45 001e CF91      		pop r28
  46               	.LVL3:
  47 0020 0895      		ret
  48               		.cfi_endproc
  49               	.LFE12:
  51               	.global	uart_init
  53               	uart_init:
  54               	.LFB11:
  45:main.c        ****     UBRR0H = UBRRH_VALUE;
  55               		.loc 1 45 0
  56               		.cfi_startproc
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 0 */
  60               	.L__stack_usage = 0
  46:main.c        ****     UBRR0L = UBRRL_VALUE;
  61               		.loc 1 46 0
  62 0022 1092 C500 		sts 197,__zero_reg__
  47:main.c        ****     
  63               		.loc 1 47 0
  64 0026 80E1      		ldi r24,lo8(16)
  65 0028 8093 C400 		sts 196,r24
  50:main.c        **** #else
  66               		.loc 1 50 0
  67 002c E0EC      		ldi r30,lo8(-64)
  68 002e F0E0      		ldi r31,0
  69 0030 8081      		ld r24,Z
  70 0032 8260      		ori r24,lo8(2)
  71 0034 8083      		st Z,r24
  55:main.c        ****     UCSR0B = _BV(RXEN0) | _BV(TXEN0);   // Enable RX and TX
  72               		.loc 1 55 0
  73 0036 86E0      		ldi r24,lo8(6)
  74 0038 8093 C200 		sts 194,r24
  56:main.c        **** }
  75               		.loc 1 56 0
  76 003c 88E1      		ldi r24,lo8(24)
  77 003e 8093 C100 		sts 193,r24
  78 0042 0895      		ret
  79               		.cfi_endproc
  80               	.LFE11:
  82               	.global	enableParkMode
  84               	enableParkMode:
  85               	.LFB13:
  68:main.c        **** 
  69:main.c        **** // Setup UART stream
  70:main.c        **** static FILE uart_output = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);
  71:main.c        **** 
  72:main.c        **** // Enable Park Mode
  73:main.c        **** void enableParkMode(void) {
  86               		.loc 1 73 0
  87               		.cfi_startproc
  88               	/* prologue: function */
  89               	/* frame size = 0 */
  90               	/* stack size = 0 */
  91               	.L__stack_usage = 0
  74:main.c        ****   PORTC &= ~_BV(PORTC0); // digitalWrite(PARK_FRONT, LOW);
  92               		.loc 1 74 0
  93 0044 4098      		cbi 0x8,0
  75:main.c        ****   PORTC &= ~_BV(PORTC1); // digitalWrite(PARK_RIGHT, LOW);
  94               		.loc 1 75 0
  95 0046 4198      		cbi 0x8,1
  76:main.c        ****   PORTC &= ~_BV(PORTC2); // digitalWrite(PARK_LEFT, LOW);
  96               		.loc 1 76 0
  97 0048 4298      		cbi 0x8,2
  77:main.c        ****   PORTC &= ~_BV(PORTC3); // digitalWrite(PARK_REAR, LOW);
  98               		.loc 1 77 0
  99 004a 4398      		cbi 0x8,3
  78:main.c        ****   // Turn PARK_STATUS LED ON
  79:main.c        ****   PORTC |= _BV(PORTC4); // digitalWrite(PARK_STATUS, HIGH);
 100               		.loc 1 79 0
 101 004c 449A      		sbi 0x8,4
  80:main.c        ****   puts_P(enablePark); // Print park mode status message
 102               		.loc 1 80 0
 103 004e 80E0      		ldi r24,lo8(enablePark)
 104 0050 90E0      		ldi r25,hi8(enablePark)
 105 0052 0E94 0000 		call puts_P
 106               	.LVL4:
 107               	.LBB8:
 108               	.LBB9:
 109               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 110               		.loc 2 187 0
 111 0056 8FE9      		ldi r24,lo8(3999)
 112 0058 9FE0      		ldi r25,hi8(3999)
 113 005a 0197      	1:	sbiw r24,1
 114 005c 01F4      		brne 1b
 115 005e 00C0      		rjmp .
 116 0060 0000      		nop
 117               	.LVL5:
 118 0062 0895      		ret
 119               	.LBE9:
 120               	.LBE8:
 121               		.cfi_endproc
 122               	.LFE13:
 124               	.global	disableParkMode
 126               	disableParkMode:
 127               	.LFB14:
  81:main.c        ****   _delay_ms(SERIAL_DELAY); // Wait for serial output to finish
  82:main.c        **** }
  83:main.c        **** 
  84:main.c        **** // Disable Park Mode
  85:main.c        **** void disableParkMode(void) {
 128               		.loc 1 85 0
 129               		.cfi_startproc
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 0 */
 133               	.L__stack_usage = 0
  86:main.c        ****   PORTC |= _BV(PORTC0); // digitalWrite(PARK_FRONT, HIGH);
 134               		.loc 1 86 0
 135 0064 409A      		sbi 0x8,0
  87:main.c        ****   PORTC |= _BV(PORTC1); // digitalWrite(PARK_RIGHT, HIGH);
 136               		.loc 1 87 0
 137 0066 419A      		sbi 0x8,1
  88:main.c        ****   PORTC |= _BV(PORTC2); // digitalWrite(PARK_LEFT, HIGH);
 138               		.loc 1 88 0
 139 0068 429A      		sbi 0x8,2
  89:main.c        ****   PORTC |= _BV(PORTC3); // digitalWrite(PARK_REAR, HIGH);
 140               		.loc 1 89 0
 141 006a 439A      		sbi 0x8,3
  90:main.c        ****   // Turn PARK_STATUS LED OFF
  91:main.c        ****   PORTC &= ~_BV(PORTC4); // digitalWrite(PARK_STATUS, LOW);
 142               		.loc 1 91 0
 143 006c 4498      		cbi 0x8,4
  92:main.c        ****   puts_P(disablePark); // Print park mode status message
 144               		.loc 1 92 0
 145 006e 80E0      		ldi r24,lo8(disablePark)
 146 0070 90E0      		ldi r25,hi8(disablePark)
 147 0072 0E94 0000 		call puts_P
 148               	.LVL6:
 149               	.LBB10:
 150               	.LBB11:
 151               		.loc 2 187 0
 152 0076 8FE9      		ldi r24,lo8(3999)
 153 0078 9FE0      		ldi r25,hi8(3999)
 154 007a 0197      	1:	sbiw r24,1
 155 007c 01F4      		brne 1b
 156 007e 00C0      		rjmp .
 157 0080 0000      		nop
 158               	.LVL7:
 159 0082 0895      		ret
 160               	.LBE11:
 161               	.LBE10:
 162               		.cfi_endproc
 163               	.LFE14:
 165               		.section	.text.startup,"ax",@progbits
 166               	.global	main
 168               	main:
 169               	.LFB15:
  93:main.c        ****   _delay_ms(SERIAL_DELAY); // Wait for serial output to finish
  94:main.c        **** }
  95:main.c        **** 
  96:main.c        **** // Main loop
  97:main.c        **** int main(void) {
 170               		.loc 1 97 0
 171               		.cfi_startproc
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
  98:main.c        ****   // Configure IO
  99:main.c        ****   DDRC |= _BV(DDC0);    // pinMode(PARK_FRONT, OUTPUT);
 176               		.loc 1 99 0
 177 0000 389A      		sbi 0x7,0
 100:main.c        ****   DDRC |= _BV(DDC1);    // pinMode(PARK_RIGHT, OUTPUT);
 178               		.loc 1 100 0
 179 0002 399A      		sbi 0x7,1
 101:main.c        ****   DDRC |= _BV(DDC2);    // pinMode(PARK_LEFT, OUTPUT);
 180               		.loc 1 101 0
 181 0004 3A9A      		sbi 0x7,2
 102:main.c        ****   DDRC |= _BV(DDC3);    // pinMode(PARK_REAR, OUTPUT);
 182               		.loc 1 102 0
 183 0006 3B9A      		sbi 0x7,3
 103:main.c        ****   DDRC |= _BV(DDC4);    // pinMode(PARK_STATUS, OUTPUT);
 184               		.loc 1 103 0
 185 0008 3C9A      		sbi 0x7,4
 104:main.c        ****   DDRB |= _BV(DDB5);    // pinMode(POWER_STATUS, OUTPUT);
 186               		.loc 1 104 0
 187 000a 259A      		sbi 0x4,5
 105:main.c        ****   DDRD &= ~_BV(DDD2);   // Clear the PD2 pin
 188               		.loc 1 105 0
 189 000c 5298      		cbi 0xa,2
 106:main.c        ****   PORTD |= _BV(PORTD2); // Enable PD2 internal pull-up
 190               		.loc 1 106 0
 191 000e 5A9A      		sbi 0xb,2
 107:main.c        ****   
 108:main.c        ****   // UART setup
 109:main.c        ****   uart_init();
 192               		.loc 1 109 0
 193 0010 0E94 0000 		call uart_init
 194               	.LVL8:
 110:main.c        ****   stdout = &uart_output;
 195               		.loc 1 110 0
 196 0014 80E0      		ldi r24,lo8(uart_output)
 197 0016 90E0      		ldi r25,hi8(uart_output)
 198 0018 9093 0000 		sts __iob+2+1,r25
 199 001c 8093 0000 		sts __iob+2,r24
 111:main.c        **** 
 112:main.c        ****   // Turn POWER_STATUS LED ON
 113:main.c        ****   PORTB |= _BV(PORTB5); // digitalWrite(POWER_STATUS, HIGH);
 200               		.loc 1 113 0
 201 0020 2D9A      		sbi 0x5,5
 114:main.c        ****   puts_P(status); // Print system status message
 202               		.loc 1 114 0
 203 0022 80E0      		ldi r24,lo8(status)
 204 0024 90E0      		ldi r25,hi8(status)
 205 0026 0E94 0000 		call puts_P
 206               	.LVL9:
 207               	.LBB12:
 208               	.LBB13:
 209               		.loc 2 187 0
 210 002a 8FE9      		ldi r24,lo8(3999)
 211 002c 9FE0      		ldi r25,hi8(3999)
 212 002e 0197      	1:	sbiw r24,1
 213 0030 01F4      		brne 1b
 214 0032 00C0      		rjmp .
 215 0034 0000      		nop
 216               	.LBE13:
 217               	.LBE12:
 115:main.c        ****   _delay_ms(SERIAL_DELAY); // Wait for serial output to finish
 116:main.c        ****  
 117:main.c        ****  // Loop
 118:main.c        ****   while(1) {
 119:main.c        ****     // Power saving
 120:main.c        ****     power_adc_disable ();
 121:main.c        ****     power_spi_disable();
 122:main.c        ****     power_twi_disable();
 123:main.c        ****     power_timer1_disable();
 124:main.c        ****     power_timer2_disable();
 125:main.c        **** 
 126:main.c        ****     // Configure sleep
 127:main.c        ****     set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 128:main.c        ****     sleep_enable();
 129:main.c        **** 
 130:main.c        ****     // Do not interrupt before to sleep or ISR will detach interrupts won't wake.
 131:main.c        ****     cli();
 132:main.c        **** 
 133:main.c        ****     // Interrupt init
 134:main.c        ****     // Enable Pin Change Interrupt on the PCINT18 pin using Pin Change Mask Register 2 (PCMSK2)
 135:main.c        ****     PCMSK2 |= _BV(PCINT18);
 136:main.c        ****     // Enable Pin Change Interrupt 2 using the Pin Change Interrupt Control Register (PCICR)
 137:main.c        ****     PCICR |= _BV(PCIE2);
 138:main.c        **** 
 139:main.c        ****     // Turn off brown-out enable in software
 140:main.c        ****     MCUCR = _BV(BODS) | _BV(BODSE);
 218               		.loc 1 140 0
 219 0036 20E6      		ldi r18,lo8(96)
 141:main.c        ****     MCUCR = _BV(BODS);
 220               		.loc 1 141 0
 221 0038 90E4      		ldi r25,lo8(64)
 222               	.L11:
 120:main.c        ****     power_spi_disable();
 223               		.loc 1 120 0 discriminator 1
 224 003a 8091 6400 		lds r24,100
 225 003e 8160      		ori r24,lo8(1)
 226 0040 8093 6400 		sts 100,r24
 121:main.c        ****     power_twi_disable();
 227               		.loc 1 121 0 discriminator 1
 228 0044 8091 6400 		lds r24,100
 229 0048 8460      		ori r24,lo8(4)
 230 004a 8093 6400 		sts 100,r24
 122:main.c        ****     power_timer1_disable();
 231               		.loc 1 122 0 discriminator 1
 232 004e 8091 6400 		lds r24,100
 233 0052 8068      		ori r24,lo8(-128)
 234 0054 8093 6400 		sts 100,r24
 123:main.c        ****     power_timer2_disable();
 235               		.loc 1 123 0 discriminator 1
 236 0058 8091 6400 		lds r24,100
 237 005c 8860      		ori r24,lo8(8)
 238 005e 8093 6400 		sts 100,r24
 124:main.c        **** 
 239               		.loc 1 124 0 discriminator 1
 240 0062 8091 6400 		lds r24,100
 241 0066 8064      		ori r24,lo8(64)
 242 0068 8093 6400 		sts 100,r24
 127:main.c        ****     sleep_enable();
 243               		.loc 1 127 0 discriminator 1
 244 006c 83B7      		in r24,0x33
 245 006e 817F      		andi r24,lo8(-15)
 246 0070 8460      		ori r24,lo8(4)
 247 0072 83BF      		out 0x33,r24
 128:main.c        **** 
 248               		.loc 1 128 0 discriminator 1
 249 0074 83B7      		in r24,0x33
 250 0076 8160      		ori r24,lo8(1)
 251 0078 83BF      		out 0x33,r24
 131:main.c        **** 
 252               		.loc 1 131 0 discriminator 1
 253               	/* #APP */
 254               	 ;  131 "main.c" 1
 255 007a F894      		cli
 256               	 ;  0 "" 2
 135:main.c        ****     // Enable Pin Change Interrupt 2 using the Pin Change Interrupt Control Register (PCICR)
 257               		.loc 1 135 0 discriminator 1
 258               	/* #NOAPP */
 259 007c 8091 6D00 		lds r24,109
 260 0080 8460      		ori r24,lo8(4)
 261 0082 8093 6D00 		sts 109,r24
 137:main.c        **** 
 262               		.loc 1 137 0 discriminator 1
 263 0086 8091 6800 		lds r24,104
 264 008a 8460      		ori r24,lo8(4)
 265 008c 8093 6800 		sts 104,r24
 140:main.c        ****     MCUCR = _BV(BODS);
 266               		.loc 1 140 0 discriminator 1
 267 0090 25BF      		out 0x35,r18
 268               		.loc 1 141 0 discriminator 1
 269 0092 95BF      		out 0x35,r25
 142:main.c        **** 
 143:main.c        ****     // Enable interrupts
 144:main.c        ****     sei();
 270               		.loc 1 144 0 discriminator 1
 271               	/* #APP */
 272               	 ;  144 "main.c" 1
 273 0094 7894      		sei
 274               	 ;  0 "" 2
 145:main.c        ****     // Guaranteed sleep_cpu call will be done as CPU executes next instruction after interrupts ena
 146:main.c        ****     sleep_cpu();
 275               		.loc 1 146 0 discriminator 1
 276               	 ;  146 "main.c" 1
 277 0096 8895      		sleep
 278               		
 279               	 ;  0 "" 2
 280               	/* #NOAPP */
 281 0098 00C0      		rjmp .L11
 282               		.cfi_endproc
 283               	.LFE15:
 285               		.text
 286               	.global	__vector_5
 288               	__vector_5:
 289               	.LFB16:
 147:main.c        ****   }
 148:main.c        **** 
 149:main.c        ****   return 0;
 150:main.c        **** }
 151:main.c        **** 
 152:main.c        **** ISR(PCINT2_vect)
 153:main.c        **** {
 290               		.loc 1 153 0
 291               		.cfi_startproc
 292 0084 1F92      		push r1
 293               	.LCFI1:
 294               		.cfi_def_cfa_offset 3
 295               		.cfi_offset 1, -2
 296 0086 0F92      		push r0
 297               	.LCFI2:
 298               		.cfi_def_cfa_offset 4
 299               		.cfi_offset 0, -3
 300 0088 0FB6      		in r0,__SREG__
 301 008a 0F92      		push r0
 302 008c 1124      		clr __zero_reg__
 303 008e 2F93      		push r18
 304               	.LCFI3:
 305               		.cfi_def_cfa_offset 5
 306               		.cfi_offset 18, -4
 307 0090 3F93      		push r19
 308               	.LCFI4:
 309               		.cfi_def_cfa_offset 6
 310               		.cfi_offset 19, -5
 311 0092 4F93      		push r20
 312               	.LCFI5:
 313               		.cfi_def_cfa_offset 7
 314               		.cfi_offset 20, -6
 315 0094 5F93      		push r21
 316               	.LCFI6:
 317               		.cfi_def_cfa_offset 8
 318               		.cfi_offset 21, -7
 319 0096 6F93      		push r22
 320               	.LCFI7:
 321               		.cfi_def_cfa_offset 9
 322               		.cfi_offset 22, -8
 323 0098 7F93      		push r23
 324               	.LCFI8:
 325               		.cfi_def_cfa_offset 10
 326               		.cfi_offset 23, -9
 327 009a 8F93      		push r24
 328               	.LCFI9:
 329               		.cfi_def_cfa_offset 11
 330               		.cfi_offset 24, -10
 331 009c 9F93      		push r25
 332               	.LCFI10:
 333               		.cfi_def_cfa_offset 12
 334               		.cfi_offset 25, -11
 335 009e AF93      		push r26
 336               	.LCFI11:
 337               		.cfi_def_cfa_offset 13
 338               		.cfi_offset 26, -12
 339 00a0 BF93      		push r27
 340               	.LCFI12:
 341               		.cfi_def_cfa_offset 14
 342               		.cfi_offset 27, -13
 343 00a2 EF93      		push r30
 344               	.LCFI13:
 345               		.cfi_def_cfa_offset 15
 346               		.cfi_offset 30, -14
 347 00a4 FF93      		push r31
 348               	.LCFI14:
 349               		.cfi_def_cfa_offset 16
 350               		.cfi_offset 31, -15
 351               	/* prologue: Signal */
 352               	/* frame size = 0 */
 353               	/* stack size = 15 */
 354               	.L__stack_usage = 15
 154:main.c        ****   // Cancel sleep as a precaution
 155:main.c        ****   sleep_disable();
 355               		.loc 1 155 0
 356 00a6 83B7      		in r24,0x33
 357 00a8 8E7F      		andi r24,lo8(-2)
 358 00aa 83BF      		out 0x33,r24
 156:main.c        ****   // Disable Pin Change Interrupt 2 while we do stuff
 157:main.c        ****   PCICR &= ~_BV(PCIE2);
 359               		.loc 1 157 0
 360 00ac 8091 6800 		lds r24,104
 361 00b0 8B7F      		andi r24,lo8(-5)
 362 00b2 8093 6800 		sts 104,r24
 158:main.c        ****   // Read PD2 using the Port D Pin Input Register (PIND)
 159:main.c        ****   if (PIND & _BV(PIND2)) { // PD2 is HIGH
 363               		.loc 1 159 0
 364 00b6 4A9B      		sbis 0x9,2
 365 00b8 00C0      		rjmp .L13
 160:main.c        ****     enableParkMode();
 366               		.loc 1 160 0
 367 00ba 0E94 0000 		call enableParkMode
 368               	.LVL10:
 369 00be 00C0      		rjmp .L12
 370               	.L13:
 161:main.c        ****   } else { // PD2 is LOW
 162:main.c        ****     disableParkMode();
 371               		.loc 1 162 0
 372 00c0 0E94 0000 		call disableParkMode
 373               	.LVL11:
 374               	.L12:
 375               	/* epilogue start */
 163:main.c        ****   }
 164:main.c        **** }
 376               		.loc 1 164 0
 377 00c4 FF91      		pop r31
 378 00c6 EF91      		pop r30
 379 00c8 BF91      		pop r27
 380 00ca AF91      		pop r26
 381 00cc 9F91      		pop r25
 382 00ce 8F91      		pop r24
 383 00d0 7F91      		pop r23
 384 00d2 6F91      		pop r22
 385 00d4 5F91      		pop r21
 386 00d6 4F91      		pop r20
 387 00d8 3F91      		pop r19
 388 00da 2F91      		pop r18
 389 00dc 0F90      		pop r0
 390 00de 0FBE      		out __SREG__,r0
 391 00e0 0F90      		pop r0
 392 00e2 1F90      		pop r1
 393 00e4 1895      		reti
 394               		.cfi_endproc
 395               	.LFE16:
 397               		.data
 400               	uart_output:
 401 0000 0000 00   		.zero	3
 402 0003 02        		.byte	2
 403 0004 0000 0000 		.zero	4
 404 0008 0000      		.word	gs(uart_putchar)
 405 000a 0000      		.word	0
 406 000c 0000      		.word	0
 407               	.global	disablePark
 408               		.section	.progmem.data,"a",@progbits
 411               	disablePark:
 412 0000 5061 726B 		.string	"Park Mode: Disabled"
 412      204D 6F64 
 412      653A 2044 
 412      6973 6162 
 412      6C65 6400 
 413               	.global	enablePark
 416               	enablePark:
 417 0014 5061 726B 		.string	"Park Mode: Enabled"
 417      204D 6F64 
 417      653A 2045 
 417      6E61 626C 
 417      6564 00
 418               	.global	status
 421               	status:
 422 0027 5379 7374 		.string	"System Status: OK"
 422      656D 2053 
 422      7461 7475 
 422      733A 204F 
 422      4B00 
 423               		.text
 424               	.Letext0:
 425               		.file 3 "/usr/lib/avr/include/stdint.h"
 426               		.file 4 "/usr/lib/avr/include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccxuEBiI.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccxuEBiI.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccxuEBiI.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccxuEBiI.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccxuEBiI.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccxuEBiI.s:11     .text:0000000000000000 uart_putchar
     /tmp/ccxuEBiI.s:53     .text:0000000000000022 uart_init
     /tmp/ccxuEBiI.s:84     .text:0000000000000044 enableParkMode
     /tmp/ccxuEBiI.s:416    .progmem.data:0000000000000014 enablePark
     /tmp/ccxuEBiI.s:126    .text:0000000000000064 disableParkMode
     /tmp/ccxuEBiI.s:411    .progmem.data:0000000000000000 disablePark
     /tmp/ccxuEBiI.s:168    .text.startup:0000000000000000 main
     /tmp/ccxuEBiI.s:400    .data:0000000000000000 uart_output
     /tmp/ccxuEBiI.s:421    .progmem.data:0000000000000027 status
     /tmp/ccxuEBiI.s:288    .text:0000000000000084 __vector_5

UNDEFINED SYMBOLS
puts_P
__iob
__do_copy_data
