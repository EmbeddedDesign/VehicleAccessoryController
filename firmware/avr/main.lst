   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	uart_putchar:
  12               	.LFB12:
  13               		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****  * Name: Vehicle Accessory Controller
   3:main.c        ****  * Author: Noctivore
   4:main.c        ****  * Description: AVR-C application code for Vehicle Accessory Controller
   5:main.c        ****  * Version 1.0
   6:main.c        ****  * Date: 9 July 2020
   7:main.c        ****  */
   8:main.c        **** 
   9:main.c        **** // Include headers
  10:main.c        **** #include <avr/power.h>
  11:main.c        **** #include <avr/sleep.h>
  12:main.c        **** #include <avr/interrupt.h>
  13:main.c        **** #include <avr/pgmspace.h>
  14:main.c        **** #include <util/delay.h>
  15:main.c        **** #include <stdio.h>
  16:main.c        **** #include "main.h"
  17:main.c        **** 
  18:main.c        **** // Serial definitions
  19:main.c        **** #ifndef F_CPU
  20:main.c        **** #define F_CPU 16000000UL
  21:main.c        **** #endif
  22:main.c        **** 
  23:main.c        **** #ifndef BAUD
  24:main.c        **** #define BAUD 115200
  25:main.c        **** #endif
  26:main.c        **** #include <util/setbaud.h>
  27:main.c        **** 
  28:main.c        **** #define SERIAL_DELAY 1
  29:main.c        **** 
  30:main.c        **** // Pin definitions
  31:main.c        **** #define PARK_FRONT   14 // A0
  32:main.c        **** #define PARK_RIGHT   15 // A1
  33:main.c        **** #define PARK_LEFT    16 // A2
  34:main.c        **** #define PARK_REAR    17 // A3
  35:main.c        **** #define PARK_STATUS  18
  36:main.c        **** #define POWER_STATUS 13
  37:main.c        **** #define ACC          2
  38:main.c        **** 
  39:main.c        **** // String constants stored in flash
  40:main.c        **** const __flash char status[] = "System Status: OK";
  41:main.c        **** const __flash char enablePark[] = "Park Mode: Enabled";
  42:main.c        **** const __flash char disablePark[] = "Park Mode: Disabled";
  43:main.c        **** 
  44:main.c        **** // URART initialization function
  45:main.c        **** void uart_init(void) {
  46:main.c        ****     UBRR0H = UBRRH_VALUE;
  47:main.c        ****     UBRR0L = UBRRL_VALUE;
  48:main.c        ****     
  49:main.c        **** #if USE_2X
  50:main.c        ****     UCSR0A |= _BV(U2X0);
  51:main.c        **** #else
  52:main.c        ****     UCSR0A &= ~(_BV(U2X0));
  53:main.c        **** #endif
  54:main.c        **** 
  55:main.c        ****     UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); // 8-bit data
  56:main.c        ****     UCSR0B = _BV(RXEN0) | _BV(TXEN0);   // Enable RX and TX
  57:main.c        **** }
  58:main.c        **** 
  59:main.c        **** // UART putchar function
  60:main.c        **** static int uart_putchar(char c, FILE *stream) {
  14               		.loc 1 60 0
  15               		.cfi_startproc
  16               	.LVL0:
  17 0000 CF93      		push r28
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 28, -2
  21               	/* prologue: function */
  22               	/* frame size = 0 */
  23               	/* stack size = 1 */
  24               	.L__stack_usage = 1
  25 0002 C82F      		mov r28,r24
  61:main.c        ****   if (c == '\n') {
  26               		.loc 1 61 0
  27 0004 8A30      		cpi r24,lo8(10)
  28 0006 01F4      		brne .L3
  62:main.c        ****     uart_putchar('\r', stream);
  29               		.loc 1 62 0
  30 0008 8DE0      		ldi r24,lo8(13)
  31               	.LVL1:
  32 000a 0E94 0000 		call uart_putchar
  33               	.LVL2:
  34               	.L3:
  63:main.c        ****   }
  64:main.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
  35               		.loc 1 64 0 discriminator 1
  36 000e 8091 C000 		lds r24,192
  37 0012 85FF      		sbrs r24,5
  38 0014 00C0      		rjmp .L3
  65:main.c        ****   UDR0 = c;
  39               		.loc 1 65 0
  40 0016 C093 C600 		sts 198,r28
  66:main.c        ****   return 0;
  67:main.c        **** }
  41               		.loc 1 67 0
  42 001a 80E0      		ldi r24,0
  43 001c 90E0      		ldi r25,0
  44               	/* epilogue start */
  45 001e CF91      		pop r28
  46               	.LVL3:
  47 0020 0895      		ret
  48               		.cfi_endproc
  49               	.LFE12:
  51               	.global	uart_init
  53               	uart_init:
  54               	.LFB11:
  45:main.c        ****     UBRR0H = UBRRH_VALUE;
  55               		.loc 1 45 0
  56               		.cfi_startproc
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 0 */
  60               	.L__stack_usage = 0
  46:main.c        ****     UBRR0L = UBRRL_VALUE;
  61               		.loc 1 46 0
  62 0022 1092 C500 		sts 197,__zero_reg__
  47:main.c        ****     
  63               		.loc 1 47 0
  64 0026 80E1      		ldi r24,lo8(16)
  65 0028 8093 C400 		sts 196,r24
  50:main.c        **** #else
  66               		.loc 1 50 0
  67 002c E0EC      		ldi r30,lo8(-64)
  68 002e F0E0      		ldi r31,0
  69 0030 8081      		ld r24,Z
  70 0032 8260      		ori r24,lo8(2)
  71 0034 8083      		st Z,r24
  55:main.c        ****     UCSR0B = _BV(RXEN0) | _BV(TXEN0);   // Enable RX and TX
  72               		.loc 1 55 0
  73 0036 86E0      		ldi r24,lo8(6)
  74 0038 8093 C200 		sts 194,r24
  56:main.c        **** }
  75               		.loc 1 56 0
  76 003c 88E1      		ldi r24,lo8(24)
  77 003e 8093 C100 		sts 193,r24
  78 0042 0895      		ret
  79               		.cfi_endproc
  80               	.LFE11:
  82               	.global	enableParkMode
  84               	enableParkMode:
  85               	.LFB13:
  68:main.c        **** 
  69:main.c        **** // Setup UART stream
  70:main.c        **** static FILE uart_output = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);
  71:main.c        **** 
  72:main.c        **** // Enable Park Mode
  73:main.c        **** void enableParkMode(void) {
  86               		.loc 1 73 0
  87               		.cfi_startproc
  88               	/* prologue: function */
  89               	/* frame size = 0 */
  90               	/* stack size = 0 */
  91               	.L__stack_usage = 0
  74:main.c        ****   PORTC &= ~_BV(PORTC0); // digitalWrite(PARK_FRONT, LOW);
  92               		.loc 1 74 0
  93 0044 4098      		cbi 0x8,0
  75:main.c        ****   PORTC &= ~_BV(PORTC1); // digitalWrite(PARK_RIGHT, LOW);
  94               		.loc 1 75 0
  95 0046 4198      		cbi 0x8,1
  76:main.c        ****   PORTC &= ~_BV(PORTC2); // digitalWrite(PARK_LEFT, LOW);
  96               		.loc 1 76 0
  97 0048 4298      		cbi 0x8,2
  77:main.c        ****   PORTC &= ~_BV(PORTC3); // digitalWrite(PARK_REAR, LOW);
  98               		.loc 1 77 0
  99 004a 4398      		cbi 0x8,3
  78:main.c        ****   // Turn PARK_STATUS LED ON
  79:main.c        ****   PORTC |= _BV(PORTC4); // digitalWrite(PARK_STATUS, HIGH);
 100               		.loc 1 79 0
 101 004c 449A      		sbi 0x8,4
  80:main.c        ****   puts_P(enablePark); // Print park mode status message
 102               		.loc 1 80 0
 103 004e 80E0      		ldi r24,lo8(enablePark)
 104 0050 90E0      		ldi r25,hi8(enablePark)
 105 0052 0E94 0000 		call puts_P
 106               	.LVL4:
 107               	.LBB8:
 108               	.LBB9:
 109               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 110               		.loc 2 187 0
 111 0056 8FE9      		ldi r24,lo8(3999)
 112 0058 9FE0      		ldi r25,hi8(3999)
 113 005a 0197      	1:	sbiw r24,1
 114 005c 01F4      		brne 1b
 115 005e 00C0      		rjmp .
 116 0060 0000      		nop
 117               	.LVL5:
 118 0062 0895      		ret
 119               	.LBE9:
 120               	.LBE8:
 121               		.cfi_endproc
 122               	.LFE13:
 124               	.global	disableParkMode
 126               	disableParkMode:
 127               	.LFB14:
  81:main.c        ****   _delay_ms(SERIAL_DELAY); // Wait for serial output to finish
  82:main.c        **** }
  83:main.c        **** 
  84:main.c        **** // Disable Park Mode
  85:main.c        **** void disableParkMode(void) {
 128               		.loc 1 85 0
 129               		.cfi_startproc
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 0 */
 133               	.L__stack_usage = 0
  86:main.c        ****   PORTC |= _BV(PORTC0); // digitalWrite(PARK_FRONT, HIGH);
 134               		.loc 1 86 0
 135 0064 409A      		sbi 0x8,0
  87:main.c        ****   PORTC |= _BV(PORTC1); // digitalWrite(PARK_RIGHT, HIGH);
 136               		.loc 1 87 0
 137 0066 419A      		sbi 0x8,1
  88:main.c        ****   PORTC |= _BV(PORTC2); // digitalWrite(PARK_LEFT, HIGH);
 138               		.loc 1 88 0
 139 0068 429A      		sbi 0x8,2
  89:main.c        ****   PORTC |= _BV(PORTC3); // digitalWrite(PARK_REAR, HIGH);
 140               		.loc 1 89 0
 141 006a 439A      		sbi 0x8,3
  90:main.c        ****   // Turn PARK_STATUS LED OFF
  91:main.c        ****   PORTC &= ~_BV(PORTC4); // digitalWrite(PARK_STATUS, LOW);
 142               		.loc 1 91 0
 143 006c 4498      		cbi 0x8,4
  92:main.c        ****   puts_P(disablePark); // Print park mode status message
 144               		.loc 1 92 0
 145 006e 80E0      		ldi r24,lo8(disablePark)
 146 0070 90E0      		ldi r25,hi8(disablePark)
 147 0072 0E94 0000 		call puts_P
 148               	.LVL6:
 149               	.LBB10:
 150               	.LBB11:
 151               		.loc 2 187 0
 152 0076 8FE9      		ldi r24,lo8(3999)
 153 0078 9FE0      		ldi r25,hi8(3999)
 154 007a 0197      	1:	sbiw r24,1
 155 007c 01F4      		brne 1b
 156 007e 00C0      		rjmp .
 157 0080 0000      		nop
 158               	.LVL7:
 159 0082 0895      		ret
 160               	.LBE11:
 161               	.LBE10:
 162               		.cfi_endproc
 163               	.LFE14:
 165               		.section	.text.startup,"ax",@progbits
 166               	.global	main
 168               	main:
 169               	.LFB15:
  93:main.c        ****   _delay_ms(SERIAL_DELAY); // Wait for serial output to finish
  94:main.c        **** }
  95:main.c        **** 
  96:main.c        **** // Main loop
  97:main.c        **** int main(void) {
 170               		.loc 1 97 0
 171               		.cfi_startproc
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
  98:main.c        ****   // Configure IO
  99:main.c        ****   DDRC |= _BV(DDC0);    // pinMode(PARK_FRONT, OUTPUT);
 176               		.loc 1 99 0
 177 0000 389A      		sbi 0x7,0
 100:main.c        ****   DDRC |= _BV(DDC1);    // pinMode(PARK_RIGHT, OUTPUT);
 178               		.loc 1 100 0
 179 0002 399A      		sbi 0x7,1
 101:main.c        ****   DDRC |= _BV(DDC2);    // pinMode(PARK_LEFT, OUTPUT);
 180               		.loc 1 101 0
 181 0004 3A9A      		sbi 0x7,2
 102:main.c        ****   DDRC |= _BV(DDC3);    // pinMode(PARK_REAR, OUTPUT);
 182               		.loc 1 102 0
 183 0006 3B9A      		sbi 0x7,3
 103:main.c        ****   DDRC |= _BV(DDC4);    // pinMode(PARK_STATUS, OUTPUT);
 184               		.loc 1 103 0
 185 0008 3C9A      		sbi 0x7,4
 104:main.c        ****   DDRB |= _BV(DDB5);    // pinMode(POWER_STATUS, OUTPUT);
 186               		.loc 1 104 0
 187 000a 259A      		sbi 0x4,5
 105:main.c        ****   DDRD &= ~_BV(DDD2);   // Clear the PD2 pin
 188               		.loc 1 105 0
 189 000c 5298      		cbi 0xa,2
 106:main.c        ****   PORTD |= _BV(PORTD2); // Enable PD2 internal pull-up
 190               		.loc 1 106 0
 191 000e 5A9A      		sbi 0xb,2
 107:main.c        ****   
 108:main.c        ****   // UART setup
 109:main.c        ****   uart_init();
 192               		.loc 1 109 0
 193 0010 0E94 0000 		call uart_init
 194               	.LVL8:
 110:main.c        ****   stdout = &uart_output;
 195               		.loc 1 110 0
 196 0014 80E0      		ldi r24,lo8(uart_output)
 197 0016 90E0      		ldi r25,hi8(uart_output)
 198 0018 9093 0000 		sts __iob+2+1,r25
 199 001c 8093 0000 		sts __iob+2,r24
 111:main.c        **** 
 112:main.c        ****   // Turn POWER_STATUS LED ON
 113:main.c        ****   PORTB |= _BV(PORTB5); // digitalWrite(POWER_STATUS, HIGH);
 200               		.loc 1 113 0
 201 0020 2D9A      		sbi 0x5,5
 114:main.c        ****   puts_P(status); // Print system status message
 202               		.loc 1 114 0
 203 0022 80E0      		ldi r24,lo8(status)
 204 0024 90E0      		ldi r25,hi8(status)
 205 0026 0E94 0000 		call puts_P
 206               	.LVL9:
 207               	.LBB12:
 208               	.LBB13:
 209               		.loc 2 187 0
 210 002a 8FE9      		ldi r24,lo8(3999)
 211 002c 9FE0      		ldi r25,hi8(3999)
 212 002e 0197      	1:	sbiw r24,1
 213 0030 01F4      		brne 1b
 214 0032 00C0      		rjmp .
 215 0034 0000      		nop
 216               	.LVL10:
 217               	.LBE13:
 218               	.LBE12:
 115:main.c        ****   _delay_ms(SERIAL_DELAY); // Wait for serial output to finish
 116:main.c        **** 
 117:main.c        ****   // Enable park mode as default state
 118:main.c        ****   enableParkMode();
 219               		.loc 1 118 0
 220 0036 0E94 0000 		call enableParkMode
 221               	.LVL11:
 119:main.c        **** 
 120:main.c        ****   // Loop
 121:main.c        ****   while(1) {
 122:main.c        ****     // Power saving
 123:main.c        ****     power_adc_disable ();
 124:main.c        ****     power_spi_disable();
 125:main.c        ****     power_twi_disable();
 126:main.c        ****     power_timer1_disable();
 127:main.c        ****     power_timer2_disable();
 128:main.c        **** 
 129:main.c        ****     // Configure sleep
 130:main.c        ****     set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 131:main.c        ****     sleep_enable();
 132:main.c        **** 
 133:main.c        ****     // Do not interrupt before to sleep or ISR will detach interrupts won't wake.
 134:main.c        ****     cli();
 135:main.c        **** 
 136:main.c        ****     // Interrupt init
 137:main.c        ****     // Enable Pin Change Interrupt on the PCINT18 pin using Pin Change Mask Register 2 (PCMSK2)
 138:main.c        ****     PCMSK2 |= _BV(PCINT18);
 139:main.c        ****     // Enable Pin Change Interrupt 2 using the Pin Change Interrupt Control Register (PCICR)
 140:main.c        ****     PCICR |= _BV(PCIE2);
 141:main.c        **** 
 142:main.c        ****     // Turn off brown-out enable in software
 143:main.c        ****     MCUCR = _BV(BODS) | _BV(BODSE);
 222               		.loc 1 143 0
 223 003a 20E6      		ldi r18,lo8(96)
 144:main.c        ****     MCUCR = _BV(BODS);
 224               		.loc 1 144 0
 225 003c 90E4      		ldi r25,lo8(64)
 226               	.L11:
 123:main.c        ****     power_spi_disable();
 227               		.loc 1 123 0 discriminator 1
 228 003e 8091 6400 		lds r24,100
 229 0042 8160      		ori r24,lo8(1)
 230 0044 8093 6400 		sts 100,r24
 124:main.c        ****     power_twi_disable();
 231               		.loc 1 124 0 discriminator 1
 232 0048 8091 6400 		lds r24,100
 233 004c 8460      		ori r24,lo8(4)
 234 004e 8093 6400 		sts 100,r24
 125:main.c        ****     power_timer1_disable();
 235               		.loc 1 125 0 discriminator 1
 236 0052 8091 6400 		lds r24,100
 237 0056 8068      		ori r24,lo8(-128)
 238 0058 8093 6400 		sts 100,r24
 126:main.c        ****     power_timer2_disable();
 239               		.loc 1 126 0 discriminator 1
 240 005c 8091 6400 		lds r24,100
 241 0060 8860      		ori r24,lo8(8)
 242 0062 8093 6400 		sts 100,r24
 127:main.c        **** 
 243               		.loc 1 127 0 discriminator 1
 244 0066 8091 6400 		lds r24,100
 245 006a 8064      		ori r24,lo8(64)
 246 006c 8093 6400 		sts 100,r24
 130:main.c        ****     sleep_enable();
 247               		.loc 1 130 0 discriminator 1
 248 0070 83B7      		in r24,0x33
 249 0072 817F      		andi r24,lo8(-15)
 250 0074 8460      		ori r24,lo8(4)
 251 0076 83BF      		out 0x33,r24
 131:main.c        **** 
 252               		.loc 1 131 0 discriminator 1
 253 0078 83B7      		in r24,0x33
 254 007a 8160      		ori r24,lo8(1)
 255 007c 83BF      		out 0x33,r24
 134:main.c        **** 
 256               		.loc 1 134 0 discriminator 1
 257               	/* #APP */
 258               	 ;  134 "main.c" 1
 259 007e F894      		cli
 260               	 ;  0 "" 2
 138:main.c        ****     // Enable Pin Change Interrupt 2 using the Pin Change Interrupt Control Register (PCICR)
 261               		.loc 1 138 0 discriminator 1
 262               	/* #NOAPP */
 263 0080 8091 6D00 		lds r24,109
 264 0084 8460      		ori r24,lo8(4)
 265 0086 8093 6D00 		sts 109,r24
 140:main.c        **** 
 266               		.loc 1 140 0 discriminator 1
 267 008a 8091 6800 		lds r24,104
 268 008e 8460      		ori r24,lo8(4)
 269 0090 8093 6800 		sts 104,r24
 143:main.c        ****     MCUCR = _BV(BODS);
 270               		.loc 1 143 0 discriminator 1
 271 0094 25BF      		out 0x35,r18
 272               		.loc 1 144 0 discriminator 1
 273 0096 95BF      		out 0x35,r25
 145:main.c        **** 
 146:main.c        ****     // Enable interrupts
 147:main.c        ****     sei();
 274               		.loc 1 147 0 discriminator 1
 275               	/* #APP */
 276               	 ;  147 "main.c" 1
 277 0098 7894      		sei
 278               	 ;  0 "" 2
 148:main.c        ****     // Guaranteed sleep_cpu call will be done as CPU executes next instruction after interrupts ena
 149:main.c        ****     sleep_cpu();
 279               		.loc 1 149 0 discriminator 1
 280               	 ;  149 "main.c" 1
 281 009a 8895      		sleep
 282               		
 283               	 ;  0 "" 2
 284               	/* #NOAPP */
 285 009c 00C0      		rjmp .L11
 286               		.cfi_endproc
 287               	.LFE15:
 289               		.text
 290               	.global	__vector_5
 292               	__vector_5:
 293               	.LFB16:
 150:main.c        ****   }
 151:main.c        **** 
 152:main.c        ****   return 0;
 153:main.c        **** }
 154:main.c        **** 
 155:main.c        **** ISR(PCINT2_vect)
 156:main.c        **** {
 294               		.loc 1 156 0
 295               		.cfi_startproc
 296 0084 1F92      		push r1
 297               	.LCFI1:
 298               		.cfi_def_cfa_offset 3
 299               		.cfi_offset 1, -2
 300 0086 0F92      		push r0
 301               	.LCFI2:
 302               		.cfi_def_cfa_offset 4
 303               		.cfi_offset 0, -3
 304 0088 0FB6      		in r0,__SREG__
 305 008a 0F92      		push r0
 306 008c 1124      		clr __zero_reg__
 307 008e 2F93      		push r18
 308               	.LCFI3:
 309               		.cfi_def_cfa_offset 5
 310               		.cfi_offset 18, -4
 311 0090 3F93      		push r19
 312               	.LCFI4:
 313               		.cfi_def_cfa_offset 6
 314               		.cfi_offset 19, -5
 315 0092 4F93      		push r20
 316               	.LCFI5:
 317               		.cfi_def_cfa_offset 7
 318               		.cfi_offset 20, -6
 319 0094 5F93      		push r21
 320               	.LCFI6:
 321               		.cfi_def_cfa_offset 8
 322               		.cfi_offset 21, -7
 323 0096 6F93      		push r22
 324               	.LCFI7:
 325               		.cfi_def_cfa_offset 9
 326               		.cfi_offset 22, -8
 327 0098 7F93      		push r23
 328               	.LCFI8:
 329               		.cfi_def_cfa_offset 10
 330               		.cfi_offset 23, -9
 331 009a 8F93      		push r24
 332               	.LCFI9:
 333               		.cfi_def_cfa_offset 11
 334               		.cfi_offset 24, -10
 335 009c 9F93      		push r25
 336               	.LCFI10:
 337               		.cfi_def_cfa_offset 12
 338               		.cfi_offset 25, -11
 339 009e AF93      		push r26
 340               	.LCFI11:
 341               		.cfi_def_cfa_offset 13
 342               		.cfi_offset 26, -12
 343 00a0 BF93      		push r27
 344               	.LCFI12:
 345               		.cfi_def_cfa_offset 14
 346               		.cfi_offset 27, -13
 347 00a2 EF93      		push r30
 348               	.LCFI13:
 349               		.cfi_def_cfa_offset 15
 350               		.cfi_offset 30, -14
 351 00a4 FF93      		push r31
 352               	.LCFI14:
 353               		.cfi_def_cfa_offset 16
 354               		.cfi_offset 31, -15
 355               	/* prologue: Signal */
 356               	/* frame size = 0 */
 357               	/* stack size = 15 */
 358               	.L__stack_usage = 15
 157:main.c        ****   // Cancel sleep as a precaution
 158:main.c        ****   sleep_disable();
 359               		.loc 1 158 0
 360 00a6 83B7      		in r24,0x33
 361 00a8 8E7F      		andi r24,lo8(-2)
 362 00aa 83BF      		out 0x33,r24
 159:main.c        ****   // Disable Pin Change Interrupt 2 while we do stuff
 160:main.c        ****   PCICR &= ~_BV(PCIE2);
 363               		.loc 1 160 0
 364 00ac 8091 6800 		lds r24,104
 365 00b0 8B7F      		andi r24,lo8(-5)
 366 00b2 8093 6800 		sts 104,r24
 161:main.c        ****   // Read PD2 using the Port D Pin Input Register (PIND)
 162:main.c        ****   if (PIND & _BV(PIND2)) { // PD2 is HIGH
 367               		.loc 1 162 0
 368 00b6 4A9B      		sbis 0x9,2
 369 00b8 00C0      		rjmp .L13
 163:main.c        ****     enableParkMode();
 370               		.loc 1 163 0
 371 00ba 0E94 0000 		call enableParkMode
 372               	.LVL12:
 373 00be 00C0      		rjmp .L12
 374               	.L13:
 164:main.c        ****   } else { // PD2 is LOW
 165:main.c        ****     disableParkMode();
 375               		.loc 1 165 0
 376 00c0 0E94 0000 		call disableParkMode
 377               	.LVL13:
 378               	.L12:
 379               	/* epilogue start */
 166:main.c        ****   }
 167:main.c        **** }
 380               		.loc 1 167 0
 381 00c4 FF91      		pop r31
 382 00c6 EF91      		pop r30
 383 00c8 BF91      		pop r27
 384 00ca AF91      		pop r26
 385 00cc 9F91      		pop r25
 386 00ce 8F91      		pop r24
 387 00d0 7F91      		pop r23
 388 00d2 6F91      		pop r22
 389 00d4 5F91      		pop r21
 390 00d6 4F91      		pop r20
 391 00d8 3F91      		pop r19
 392 00da 2F91      		pop r18
 393 00dc 0F90      		pop r0
 394 00de 0FBE      		out __SREG__,r0
 395 00e0 0F90      		pop r0
 396 00e2 1F90      		pop r1
 397 00e4 1895      		reti
 398               		.cfi_endproc
 399               	.LFE16:
 401               		.data
 404               	uart_output:
 405 0000 0000 00   		.zero	3
 406 0003 02        		.byte	2
 407 0004 0000 0000 		.zero	4
 408 0008 0000      		.word	gs(uart_putchar)
 409 000a 0000      		.word	0
 410 000c 0000      		.word	0
 411               	.global	disablePark
 412               		.section	.progmem.data,"a",@progbits
 415               	disablePark:
 416 0000 5061 726B 		.string	"Park Mode: Disabled"
 416      204D 6F64 
 416      653A 2044 
 416      6973 6162 
 416      6C65 6400 
 417               	.global	enablePark
 420               	enablePark:
 421 0014 5061 726B 		.string	"Park Mode: Enabled"
 421      204D 6F64 
 421      653A 2045 
 421      6E61 626C 
 421      6564 00
 422               	.global	status
 425               	status:
 426 0027 5379 7374 		.string	"System Status: OK"
 426      656D 2053 
 426      7461 7475 
 426      733A 204F 
 426      4B00 
 427               		.text
 428               	.Letext0:
 429               		.file 3 "/usr/lib/avr/include/stdint.h"
 430               		.file 4 "/usr/lib/avr/include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccEYRHgd.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccEYRHgd.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccEYRHgd.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccEYRHgd.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccEYRHgd.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccEYRHgd.s:11     .text:0000000000000000 uart_putchar
     /tmp/ccEYRHgd.s:53     .text:0000000000000022 uart_init
     /tmp/ccEYRHgd.s:84     .text:0000000000000044 enableParkMode
     /tmp/ccEYRHgd.s:420    .progmem.data:0000000000000014 enablePark
     /tmp/ccEYRHgd.s:126    .text:0000000000000064 disableParkMode
     /tmp/ccEYRHgd.s:415    .progmem.data:0000000000000000 disablePark
     /tmp/ccEYRHgd.s:168    .text.startup:0000000000000000 main
     /tmp/ccEYRHgd.s:404    .data:0000000000000000 uart_output
     /tmp/ccEYRHgd.s:425    .progmem.data:0000000000000027 status
     /tmp/ccEYRHgd.s:292    .text:0000000000000084 __vector_5

UNDEFINED SYMBOLS
puts_P
__iob
__do_copy_data
