   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	uart_putchar:
  12               	.LFB6:
  13               		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****  * Name: Vehicle Accessory Controller
   3:main.c        ****  * Author: Noctivore
   4:main.c        ****  * Description: AVR-C application code for Vehicle Accessory Controller
   5:main.c        ****  * Version 1.0
   6:main.c        ****  * Date: 8 July 2020
   7:main.c        ****  */
   8:main.c        **** 
   9:main.c        ****  // Include headers
  10:main.c        **** #include <avr/power.h>
  11:main.c        **** #include <avr/sleep.h>
  12:main.c        **** #include <avr/interrupt.h>
  13:main.c        **** #include <avr/pgmspace.h>
  14:main.c        **** #include <stdio.h>
  15:main.c        **** #include "main.h"
  16:main.c        **** // #include "uart.h"
  17:main.c        **** 
  18:main.c        **** #ifndef F_CPU
  19:main.c        **** #define F_CPU 16000000UL
  20:main.c        **** #endif
  21:main.c        **** 
  22:main.c        **** #ifndef BAUD
  23:main.c        **** #define BAUD 115200
  24:main.c        **** #endif
  25:main.c        **** #include <util/setbaud.h>
  26:main.c        **** 
  27:main.c        **** // Pin definitions
  28:main.c        **** #define PARK_FRONT   14 // A0
  29:main.c        **** #define PARK_RIGHT   15 // A1
  30:main.c        **** #define PARK_LEFT    16 // A2
  31:main.c        **** #define PARK_REAR    17 // A3
  32:main.c        **** #define PARK_STATUS  18
  33:main.c        **** #define POWER_STATUS 13
  34:main.c        **** #define ACC          2
  35:main.c        **** 
  36:main.c        **** const char status[] PROGMEM = "System Status: OK";
  37:main.c        **** 
  38:main.c        **** // URART initialization function
  39:main.c        **** void uart_init(void) {
  40:main.c        ****     UBRR0H = UBRRH_VALUE;
  41:main.c        ****     UBRR0L = UBRRL_VALUE;
  42:main.c        ****     
  43:main.c        **** #if USE_2X
  44:main.c        ****     UCSR0A |= _BV(U2X0);
  45:main.c        **** #else
  46:main.c        ****     UCSR0A &= ~(_BV(U2X0));
  47:main.c        **** #endif
  48:main.c        **** 
  49:main.c        ****     UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); // 8-bit data
  50:main.c        ****     UCSR0B = _BV(RXEN0) | _BV(TXEN0);   // Enable RX and TX
  51:main.c        **** }
  52:main.c        **** 
  53:main.c        **** // UART putchar function
  54:main.c        **** static void uart_putchar(char c, FILE *stream) {
  14               		.loc 1 54 0
  15               		.cfi_startproc
  16               	.LVL0:
  17 0000 CF93      		push r28
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 28, -2
  21               	/* prologue: function */
  22               	/* frame size = 0 */
  23               	/* stack size = 1 */
  24               	.L__stack_usage = 1
  25 0002 C82F      		mov r28,r24
  55:main.c        ****     if (c == '\n') {
  26               		.loc 1 55 0
  27 0004 8A30      		cpi r24,lo8(10)
  28 0006 01F4      		brne .L3
  56:main.c        ****         uart_putchar('\r', stream);
  29               		.loc 1 56 0
  30 0008 8DE0      		ldi r24,lo8(13)
  31               	.LVL1:
  32 000a 0E94 0000 		call uart_putchar
  33               	.LVL2:
  34               	.L3:
  57:main.c        ****     }
  58:main.c        ****     loop_until_bit_is_set(UCSR0A, UDRE0);
  35               		.loc 1 58 0 discriminator 1
  36 000e 8091 C000 		lds r24,192
  37 0012 85FF      		sbrs r24,5
  38 0014 00C0      		rjmp .L3
  59:main.c        ****     UDR0 = c;
  39               		.loc 1 59 0
  40 0016 C093 C600 		sts 198,r28
  41               	/* epilogue start */
  60:main.c        **** }
  42               		.loc 1 60 0
  43 001a CF91      		pop r28
  44               	.LVL3:
  45 001c 0895      		ret
  46               		.cfi_endproc
  47               	.LFE6:
  49               	.global	uart_init
  51               	uart_init:
  52               	.LFB5:
  39:main.c        ****     UBRR0H = UBRRH_VALUE;
  53               		.loc 1 39 0
  54               		.cfi_startproc
  55               	/* prologue: function */
  56               	/* frame size = 0 */
  57               	/* stack size = 0 */
  58               	.L__stack_usage = 0
  40:main.c        ****     UBRR0L = UBRRL_VALUE;
  59               		.loc 1 40 0
  60 001e 1092 C500 		sts 197,__zero_reg__
  41:main.c        ****     
  61               		.loc 1 41 0
  62 0022 80E1      		ldi r24,lo8(16)
  63 0024 8093 C400 		sts 196,r24
  44:main.c        **** #else
  64               		.loc 1 44 0
  65 0028 E0EC      		ldi r30,lo8(-64)
  66 002a F0E0      		ldi r31,0
  67 002c 8081      		ld r24,Z
  68 002e 8260      		ori r24,lo8(2)
  69 0030 8083      		st Z,r24
  49:main.c        ****     UCSR0B = _BV(RXEN0) | _BV(TXEN0);   // Enable RX and TX
  70               		.loc 1 49 0
  71 0032 86E0      		ldi r24,lo8(6)
  72 0034 8093 C200 		sts 194,r24
  50:main.c        **** }
  73               		.loc 1 50 0
  74 0038 88E1      		ldi r24,lo8(24)
  75 003a 8093 C100 		sts 193,r24
  76 003e 0895      		ret
  77               		.cfi_endproc
  78               	.LFE5:
  80               	.global	USART_TxString_P
  82               	USART_TxString_P:
  83               	.LFB7:
  61:main.c        **** 
  62:main.c        **** // Setup stream
  63:main.c        **** static FILE uart_output = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);
  64:main.c        **** 
  65:main.c        **** void USART_TxString_P(const char *data) {
  84               		.loc 1 65 0
  85               		.cfi_startproc
  86               	.LVL4:
  87 0040 CF93      		push r28
  88               	.LCFI1:
  89               		.cfi_def_cfa_offset 3
  90               		.cfi_offset 28, -2
  91 0042 DF93      		push r29
  92               	.LCFI2:
  93               		.cfi_def_cfa_offset 4
  94               		.cfi_offset 29, -3
  95               	/* prologue: function */
  96               	/* frame size = 0 */
  97               	/* stack size = 2 */
  98               	.L__stack_usage = 2
  99 0044 EC01      		movw r28,r24
 100               	.LVL5:
 101               	.L9:
 102               	.LBB2:
  66:main.c        ****   while (pgm_read_byte(*data) != 0x00) {
 103               		.loc 1 66 0
 104 0046 E991      		ld r30,Y+
 105               	.LVL6:
 106 0048 F0E0      		ldi r31,0
 107               	.LVL7:
 108               	/* #APP */
 109               	 ;  66 "main.c" 1
 110 004a 8491      		lpm r24, Z
 111               		
 112               	 ;  0 "" 2
 113               	.LVL8:
 114               	/* #NOAPP */
 115               	.LBE2:
 116 004c 8823      		tst r24
 117 004e 01F0      		breq .L11
 118               	.LVL9:
 119               	.LBB3:
  67:main.c        ****     putc(pgm_read_byte(*data++), &uart_output);
 120               		.loc 1 67 0
 121               	/* #APP */
 122               	 ;  67 "main.c" 1
 123 0050 8491      		lpm r24, Z
 124               		
 125               	 ;  0 "" 2
 126               	.LVL10:
 127               	/* #NOAPP */
 128               	.LBE3:
 129 0052 60E0      		ldi r22,lo8(uart_output)
 130 0054 70E0      		ldi r23,hi8(uart_output)
 131 0056 90E0      		ldi r25,0
 132 0058 0E94 0000 		call fputc
 133               	.LVL11:
 134 005c 00C0      		rjmp .L9
 135               	.LVL12:
 136               	.L11:
 137               	/* epilogue start */
  68:main.c        ****   }
  69:main.c        **** }
 138               		.loc 1 69 0
 139 005e DF91      		pop r29
 140 0060 CF91      		pop r28
 141               	.LVL13:
 142 0062 0895      		ret
 143               		.cfi_endproc
 144               	.LFE7:
 146               		.section	.rodata.str1.1,"aMS",@progbits,1
 147               	.LC0:
 148 0000 5061 726B 		.string	"Park Mode: Enabled"
 148      204D 6F64 
 148      653A 2045 
 148      6E61 626C 
 148      6564 00
 149               		.text
 150               	.global	enableParkMode
 152               	enableParkMode:
 153               	.LFB8:
  70:main.c        **** 
  71:main.c        **** // Enable Park Mode
  72:main.c        **** void enableParkMode(void) {
 154               		.loc 1 72 0
 155               		.cfi_startproc
 156               	/* prologue: function */
 157               	/* frame size = 0 */
 158               	/* stack size = 0 */
 159               	.L__stack_usage = 0
  73:main.c        ****   PORTC &= ~_BV(PORTC0); // digitalWrite(PARK_FRONT, LOW);
 160               		.loc 1 73 0
 161 0064 4098      		cbi 0x8,0
  74:main.c        ****   PORTC &= ~_BV(PORTC1); // digitalWrite(PARK_RIGHT, LOW);
 162               		.loc 1 74 0
 163 0066 4198      		cbi 0x8,1
  75:main.c        ****   PORTC &= ~_BV(PORTC2); // digitalWrite(PARK_LEFT, LOW);
 164               		.loc 1 75 0
 165 0068 4298      		cbi 0x8,2
  76:main.c        ****   PORTC &= ~_BV(PORTC3); // digitalWrite(PARK_REAR, LOW);
 166               		.loc 1 76 0
 167 006a 4398      		cbi 0x8,3
  77:main.c        ****   // Turn PARK_STATUS LED ON
  78:main.c        ****   PORTC |= _BV(PORTC4); // digitalWrite(PARK_STATUS, HIGH);
 168               		.loc 1 78 0
 169 006c 449A      		sbi 0x8,4
  79:main.c        ****   // puts_P(PSTR("Park Mode: Enabled")); // Print park mode status message
  80:main.c        ****   puts("Park Mode: Enabled"); // Print park mode status message
 170               		.loc 1 80 0
 171 006e 80E0      		ldi r24,lo8(.LC0)
 172 0070 90E0      		ldi r25,hi8(.LC0)
 173 0072 0C94 0000 		jmp puts
 174               	.LVL14:
 175               		.cfi_endproc
 176               	.LFE8:
 178               		.section	.rodata.str1.1
 179               	.LC1:
 180 0013 5061 726B 		.string	"Park Mode: Disabled"
 180      204D 6F64 
 180      653A 2044 
 180      6973 6162 
 180      6C65 6400 
 181               		.text
 182               	.global	disableParkMode
 184               	disableParkMode:
 185               	.LFB9:
  81:main.c        **** }
  82:main.c        **** 
  83:main.c        **** // Disable Park Mode
  84:main.c        **** void disableParkMode(void) {
 186               		.loc 1 84 0
 187               		.cfi_startproc
 188               	/* prologue: function */
 189               	/* frame size = 0 */
 190               	/* stack size = 0 */
 191               	.L__stack_usage = 0
  85:main.c        ****   PORTC |= _BV(PORTC0); // digitalWrite(PARK_FRONT, HIGH);
 192               		.loc 1 85 0
 193 0076 409A      		sbi 0x8,0
  86:main.c        ****   PORTC |= _BV(PORTC1); // digitalWrite(PARK_RIGHT, HIGH);
 194               		.loc 1 86 0
 195 0078 419A      		sbi 0x8,1
  87:main.c        ****   PORTC |= _BV(PORTC2); // digitalWrite(PARK_LEFT, HIGH);
 196               		.loc 1 87 0
 197 007a 429A      		sbi 0x8,2
  88:main.c        ****   PORTC |= _BV(PORTC3); // digitalWrite(PARK_REAR, HIGH);
 198               		.loc 1 88 0
 199 007c 439A      		sbi 0x8,3
  89:main.c        ****   // Turn PARK_STATUS LED OFF
  90:main.c        ****   PORTC &= ~_BV(PORTC4); // digitalWrite(PARK_STATUS, LOW);
 200               		.loc 1 90 0
 201 007e 4498      		cbi 0x8,4
  91:main.c        ****   // puts_P(PSTR("Park Mode: Disabled")); // Print park mode status message
  92:main.c        ****   puts("Park Mode: Disabled"); // Print park mode status message
 202               		.loc 1 92 0
 203 0080 80E0      		ldi r24,lo8(.LC1)
 204 0082 90E0      		ldi r25,hi8(.LC1)
 205 0084 0C94 0000 		jmp puts
 206               	.LVL15:
 207               		.cfi_endproc
 208               	.LFE9:
 210               		.section	.text.startup,"ax",@progbits
 211               	.global	main
 213               	main:
 214               	.LFB10:
  93:main.c        **** }
  94:main.c        **** 
  95:main.c        **** // Main loop
  96:main.c        **** int main(void) {
 215               		.loc 1 96 0
 216               		.cfi_startproc
 217               	/* prologue: function */
 218               	/* frame size = 0 */
 219               	/* stack size = 0 */
 220               	.L__stack_usage = 0
  97:main.c        ****   // Configure IO
  98:main.c        ****   DDRC |= _BV(DDC0);    // pinMode(PARK_FRONT, OUTPUT);
 221               		.loc 1 98 0
 222 0000 389A      		sbi 0x7,0
  99:main.c        ****   DDRC |= _BV(DDC1);    // pinMode(PARK_RIGHT, OUTPUT);
 223               		.loc 1 99 0
 224 0002 399A      		sbi 0x7,1
 100:main.c        ****   DDRC |= _BV(DDC2);    // pinMode(PARK_LEFT, OUTPUT);
 225               		.loc 1 100 0
 226 0004 3A9A      		sbi 0x7,2
 101:main.c        ****   DDRC |= _BV(DDC3);    // pinMode(PARK_REAR, OUTPUT);
 227               		.loc 1 101 0
 228 0006 3B9A      		sbi 0x7,3
 102:main.c        ****   DDRC |= _BV(DDC4);    // pinMode(PARK_STATUS, OUTPUT);
 229               		.loc 1 102 0
 230 0008 3C9A      		sbi 0x7,4
 103:main.c        ****   DDRB |= _BV(DDB5);    // pinMode(POWER_STATUS, OUTPUT);
 231               		.loc 1 103 0
 232 000a 259A      		sbi 0x4,5
 104:main.c        ****   DDRD &= ~_BV(DDD2);   // Clear the PD2 pin
 233               		.loc 1 104 0
 234 000c 5298      		cbi 0xa,2
 105:main.c        ****   PORTD |= _BV(PORTD2); // Enable PD2 internal pull-up
 235               		.loc 1 105 0
 236 000e 5A9A      		sbi 0xb,2
 106:main.c        ****   
 107:main.c        ****   // UART setup
 108:main.c        ****   uart_init();
 237               		.loc 1 108 0
 238 0010 0E94 0000 		call uart_init
 239               	.LVL16:
 109:main.c        ****   stdout = &uart_output;
 240               		.loc 1 109 0
 241 0014 80E0      		ldi r24,lo8(uart_output)
 242 0016 90E0      		ldi r25,hi8(uart_output)
 243 0018 9093 0000 		sts __iob+2+1,r25
 244 001c 8093 0000 		sts __iob+2,r24
 110:main.c        ****   // stdin  = &uart_input;
 111:main.c        **** 
 112:main.c        ****   // Turn POWER_STATUS LED ON
 113:main.c        ****   PORTB |= _BV(PORTB5); // digitalWrite(POWER_STATUS, HIGH);
 245               		.loc 1 113 0
 246 0020 2D9A      		sbi 0x5,5
 114:main.c        ****   // Print system status message
 115:main.c        ****   // printf_P(PSTR("System Status: OK"));
 116:main.c        ****   // puts_P(status);
 117:main.c        ****   USART_TxString_P(status);
 247               		.loc 1 117 0
 248 0022 80E0      		ldi r24,lo8(status)
 249 0024 90E0      		ldi r25,hi8(status)
 250 0026 0E94 0000 		call USART_TxString_P
 251               	.LVL17:
 118:main.c        ****   // puts("System Status: OK");
 119:main.c        ****  
 120:main.c        ****  // Loop
 121:main.c        ****   while(1) {
 122:main.c        ****     // Power saving
 123:main.c        ****     power_adc_disable ();
 124:main.c        ****     power_spi_disable();
 125:main.c        ****     power_twi_disable();
 126:main.c        ****     power_timer1_disable();
 127:main.c        ****     power_timer2_disable();
 128:main.c        **** 
 129:main.c        ****     // Configure sleep
 130:main.c        ****     set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 131:main.c        ****     sleep_enable();
 132:main.c        **** 
 133:main.c        ****     // Do not interrupt before to sleep or ISR will detach interrupts won't wake.
 134:main.c        ****     cli();
 135:main.c        **** 
 136:main.c        ****     // Interrupt init
 137:main.c        ****     // Enable Pin Change Interrupt on the PCINT18 pin using Pin Change Mask Register 2 (PCMSK2)
 138:main.c        ****     PCMSK2 |= _BV(PCINT18);
 139:main.c        ****     // Enable Pin Change Interrupt 2 using the Pin Change Interrupt Control Register (PCICR)
 140:main.c        ****     PCICR |= _BV(PCIE2);
 141:main.c        **** 
 142:main.c        ****     // Turn off brown-out enable in software
 143:main.c        ****     MCUCR = _BV(BODS) | _BV(BODSE);
 252               		.loc 1 143 0
 253 002a 20E6      		ldi r18,lo8(96)
 144:main.c        ****     MCUCR = _BV(BODS);
 254               		.loc 1 144 0
 255 002c 90E4      		ldi r25,lo8(64)
 256               	.L15:
 123:main.c        ****     power_spi_disable();
 257               		.loc 1 123 0 discriminator 1
 258 002e 8091 6400 		lds r24,100
 259 0032 8160      		ori r24,lo8(1)
 260 0034 8093 6400 		sts 100,r24
 124:main.c        ****     power_twi_disable();
 261               		.loc 1 124 0 discriminator 1
 262 0038 8091 6400 		lds r24,100
 263 003c 8460      		ori r24,lo8(4)
 264 003e 8093 6400 		sts 100,r24
 125:main.c        ****     power_timer1_disable();
 265               		.loc 1 125 0 discriminator 1
 266 0042 8091 6400 		lds r24,100
 267 0046 8068      		ori r24,lo8(-128)
 268 0048 8093 6400 		sts 100,r24
 126:main.c        ****     power_timer2_disable();
 269               		.loc 1 126 0 discriminator 1
 270 004c 8091 6400 		lds r24,100
 271 0050 8860      		ori r24,lo8(8)
 272 0052 8093 6400 		sts 100,r24
 127:main.c        **** 
 273               		.loc 1 127 0 discriminator 1
 274 0056 8091 6400 		lds r24,100
 275 005a 8064      		ori r24,lo8(64)
 276 005c 8093 6400 		sts 100,r24
 130:main.c        ****     sleep_enable();
 277               		.loc 1 130 0 discriminator 1
 278 0060 83B7      		in r24,0x33
 279 0062 817F      		andi r24,lo8(-15)
 280 0064 8460      		ori r24,lo8(4)
 281 0066 83BF      		out 0x33,r24
 131:main.c        **** 
 282               		.loc 1 131 0 discriminator 1
 283 0068 83B7      		in r24,0x33
 284 006a 8160      		ori r24,lo8(1)
 285 006c 83BF      		out 0x33,r24
 134:main.c        **** 
 286               		.loc 1 134 0 discriminator 1
 287               	/* #APP */
 288               	 ;  134 "main.c" 1
 289 006e F894      		cli
 290               	 ;  0 "" 2
 138:main.c        ****     // Enable Pin Change Interrupt 2 using the Pin Change Interrupt Control Register (PCICR)
 291               		.loc 1 138 0 discriminator 1
 292               	/* #NOAPP */
 293 0070 8091 6D00 		lds r24,109
 294 0074 8460      		ori r24,lo8(4)
 295 0076 8093 6D00 		sts 109,r24
 140:main.c        **** 
 296               		.loc 1 140 0 discriminator 1
 297 007a 8091 6800 		lds r24,104
 298 007e 8460      		ori r24,lo8(4)
 299 0080 8093 6800 		sts 104,r24
 143:main.c        ****     MCUCR = _BV(BODS);
 300               		.loc 1 143 0 discriminator 1
 301 0084 25BF      		out 0x35,r18
 302               		.loc 1 144 0 discriminator 1
 303 0086 95BF      		out 0x35,r25
 145:main.c        **** 
 146:main.c        ****     // Enable interrupts
 147:main.c        ****     sei();
 304               		.loc 1 147 0 discriminator 1
 305               	/* #APP */
 306               	 ;  147 "main.c" 1
 307 0088 7894      		sei
 308               	 ;  0 "" 2
 148:main.c        ****     // Guaranteed sleep_cpu call will be done as CPU executes next instruction after interrupts ena
 149:main.c        ****     sleep_cpu();
 309               		.loc 1 149 0 discriminator 1
 310               	 ;  149 "main.c" 1
 311 008a 8895      		sleep
 312               		
 313               	 ;  0 "" 2
 314               	/* #NOAPP */
 315 008c 00C0      		rjmp .L15
 316               		.cfi_endproc
 317               	.LFE10:
 319               		.text
 320               	.global	__vector_5
 322               	__vector_5:
 323               	.LFB11:
 150:main.c        ****   }
 151:main.c        **** 
 152:main.c        ****   return 0;
 153:main.c        **** }
 154:main.c        **** 
 155:main.c        **** ISR(PCINT2_vect)
 156:main.c        **** {
 324               		.loc 1 156 0
 325               		.cfi_startproc
 326 0088 1F92      		push r1
 327               	.LCFI3:
 328               		.cfi_def_cfa_offset 3
 329               		.cfi_offset 1, -2
 330 008a 0F92      		push r0
 331               	.LCFI4:
 332               		.cfi_def_cfa_offset 4
 333               		.cfi_offset 0, -3
 334 008c 0FB6      		in r0,__SREG__
 335 008e 0F92      		push r0
 336 0090 1124      		clr __zero_reg__
 337 0092 2F93      		push r18
 338               	.LCFI5:
 339               		.cfi_def_cfa_offset 5
 340               		.cfi_offset 18, -4
 341 0094 3F93      		push r19
 342               	.LCFI6:
 343               		.cfi_def_cfa_offset 6
 344               		.cfi_offset 19, -5
 345 0096 4F93      		push r20
 346               	.LCFI7:
 347               		.cfi_def_cfa_offset 7
 348               		.cfi_offset 20, -6
 349 0098 5F93      		push r21
 350               	.LCFI8:
 351               		.cfi_def_cfa_offset 8
 352               		.cfi_offset 21, -7
 353 009a 6F93      		push r22
 354               	.LCFI9:
 355               		.cfi_def_cfa_offset 9
 356               		.cfi_offset 22, -8
 357 009c 7F93      		push r23
 358               	.LCFI10:
 359               		.cfi_def_cfa_offset 10
 360               		.cfi_offset 23, -9
 361 009e 8F93      		push r24
 362               	.LCFI11:
 363               		.cfi_def_cfa_offset 11
 364               		.cfi_offset 24, -10
 365 00a0 9F93      		push r25
 366               	.LCFI12:
 367               		.cfi_def_cfa_offset 12
 368               		.cfi_offset 25, -11
 369 00a2 AF93      		push r26
 370               	.LCFI13:
 371               		.cfi_def_cfa_offset 13
 372               		.cfi_offset 26, -12
 373 00a4 BF93      		push r27
 374               	.LCFI14:
 375               		.cfi_def_cfa_offset 14
 376               		.cfi_offset 27, -13
 377 00a6 EF93      		push r30
 378               	.LCFI15:
 379               		.cfi_def_cfa_offset 15
 380               		.cfi_offset 30, -14
 381 00a8 FF93      		push r31
 382               	.LCFI16:
 383               		.cfi_def_cfa_offset 16
 384               		.cfi_offset 31, -15
 385               	/* prologue: Signal */
 386               	/* frame size = 0 */
 387               	/* stack size = 15 */
 388               	.L__stack_usage = 15
 157:main.c        ****   // Cancel sleep as a precaution
 158:main.c        ****   sleep_disable();
 389               		.loc 1 158 0
 390 00aa 83B7      		in r24,0x33
 391 00ac 8E7F      		andi r24,lo8(-2)
 392 00ae 83BF      		out 0x33,r24
 159:main.c        ****   // Disable Pin Change Interrupt 2 while we do other stuff
 160:main.c        ****   PCICR &= ~_BV(PCIE2);
 393               		.loc 1 160 0
 394 00b0 8091 6800 		lds r24,104
 395 00b4 8B7F      		andi r24,lo8(-5)
 396 00b6 8093 6800 		sts 104,r24
 161:main.c        ****   // Read PD2 using the Port D Pin Input Register (PIND)
 162:main.c        ****   if (PIND & _BV(PIND2)) { // PD2 is HIGH
 397               		.loc 1 162 0
 398 00ba 4A9B      		sbis 0x9,2
 399 00bc 00C0      		rjmp .L17
 163:main.c        ****     enableParkMode();
 400               		.loc 1 163 0
 401 00be 0E94 0000 		call enableParkMode
 402               	.LVL18:
 403 00c2 00C0      		rjmp .L16
 404               	.L17:
 164:main.c        ****   } else { // PD2 is LOW
 165:main.c        ****     disableParkMode();
 405               		.loc 1 165 0
 406 00c4 0E94 0000 		call disableParkMode
 407               	.LVL19:
 408               	.L16:
 409               	/* epilogue start */
 166:main.c        ****   }
 167:main.c        **** }
 410               		.loc 1 167 0
 411 00c8 FF91      		pop r31
 412 00ca EF91      		pop r30
 413 00cc BF91      		pop r27
 414 00ce AF91      		pop r26
 415 00d0 9F91      		pop r25
 416 00d2 8F91      		pop r24
 417 00d4 7F91      		pop r23
 418 00d6 6F91      		pop r22
 419 00d8 5F91      		pop r21
 420 00da 4F91      		pop r20
 421 00dc 3F91      		pop r19
 422 00de 2F91      		pop r18
 423 00e0 0F90      		pop r0
 424 00e2 0FBE      		out __SREG__,r0
 425 00e4 0F90      		pop r0
 426 00e6 1F90      		pop r1
 427 00e8 1895      		reti
 428               		.cfi_endproc
 429               	.LFE11:
 431               		.data
 434               	uart_output:
 435 0000 0000 00   		.zero	3
 436 0003 02        		.byte	2
 437 0004 0000 0000 		.zero	4
 438 0008 0000      		.word	gs(uart_putchar)
 439 000a 0000      		.word	0
 440 000c 0000      		.word	0
 441               	.global	status
 442               		.section	.progmem.data,"a",@progbits
 445               	status:
 446 0000 5379 7374 		.string	"System Status: OK"
 446      656D 2053 
 446      7461 7475 
 446      733A 204F 
 446      4B00 
 447               		.text
 448               	.Letext0:
 449               		.file 2 "/usr/lib/avr/include/stdint.h"
 450               		.file 3 "/usr/lib/avr/include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccHGf9oN.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccHGf9oN.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccHGf9oN.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccHGf9oN.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccHGf9oN.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccHGf9oN.s:11     .text:0000000000000000 uart_putchar
     /tmp/ccHGf9oN.s:51     .text:000000000000001e uart_init
     /tmp/ccHGf9oN.s:82     .text:0000000000000040 USART_TxString_P
     /tmp/ccHGf9oN.s:434    .data:0000000000000000 uart_output
     /tmp/ccHGf9oN.s:152    .text:0000000000000064 enableParkMode
     /tmp/ccHGf9oN.s:184    .text:0000000000000076 disableParkMode
     /tmp/ccHGf9oN.s:213    .text.startup:0000000000000000 main
     /tmp/ccHGf9oN.s:445    .progmem.data:0000000000000000 status
     /tmp/ccHGf9oN.s:322    .text:0000000000000088 __vector_5

UNDEFINED SYMBOLS
fputc
puts
__iob
__do_copy_data
