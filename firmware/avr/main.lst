   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	uart_putchar:
  12               	.LFB12:
  13               		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****  * Name: Vehicle Accessory Controller
   3:main.c        ****  * Author: Noctivore
   4:main.c        ****  * Description: AVR-C application code for Vehicle Accessory Controller
   5:main.c        ****  * Version 1.0
   6:main.c        ****  * Date: 9 July 2020
   7:main.c        ****  */
   8:main.c        **** 
   9:main.c        **** // Include headers
  10:main.c        **** #include <avr/power.h>
  11:main.c        **** #include <avr/sleep.h>
  12:main.c        **** #include <avr/interrupt.h>
  13:main.c        **** #include <avr/pgmspace.h>
  14:main.c        **** #include <util/delay.h>
  15:main.c        **** #include <stdio.h>
  16:main.c        **** #include "main.h"
  17:main.c        **** 
  18:main.c        **** // Serial definitions
  19:main.c        **** #ifndef F_CPU
  20:main.c        **** #define F_CPU 16000000UL
  21:main.c        **** #endif
  22:main.c        **** 
  23:main.c        **** #ifndef BAUD
  24:main.c        **** #define BAUD 115200
  25:main.c        **** #endif
  26:main.c        **** #include <util/setbaud.h>
  27:main.c        **** 
  28:main.c        **** #define SERIAL_DELAY 10
  29:main.c        **** 
  30:main.c        **** // Pin definitions
  31:main.c        **** #define PARK_FRONT   14 // A0
  32:main.c        **** #define PARK_RIGHT   15 // A1
  33:main.c        **** #define PARK_LEFT    16 // A2
  34:main.c        **** #define PARK_REAR    17 // A3
  35:main.c        **** #define PARK_STATUS  18
  36:main.c        **** #define POWER_STATUS 13
  37:main.c        **** #define ACC          2
  38:main.c        **** 
  39:main.c        **** // String constants stored in flash
  40:main.c        **** const __flash char status[] = "System Status: OK";
  41:main.c        **** const __flash char enablePark[] = "Park Mode: Enabled";
  42:main.c        **** const __flash char disablePark[] = "Park Mode: Disabled";
  43:main.c        **** 
  44:main.c        **** // URART initialization function
  45:main.c        **** void uart_init(void) {
  46:main.c        ****     UBRR0H = UBRRH_VALUE;
  47:main.c        ****     UBRR0L = UBRRL_VALUE;
  48:main.c        ****     
  49:main.c        **** #if USE_2X
  50:main.c        ****     UCSR0A |= _BV(U2X0);
  51:main.c        **** #else
  52:main.c        ****     UCSR0A &= ~(_BV(U2X0));
  53:main.c        **** #endif
  54:main.c        **** 
  55:main.c        ****     UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); // 8-bit data
  56:main.c        ****     UCSR0B = _BV(RXEN0) | _BV(TXEN0);   // Enable RX and TX
  57:main.c        **** }
  58:main.c        **** 
  59:main.c        **** // UART putchar function
  60:main.c        **** static int uart_putchar(char c, FILE *stream) {
  14               		.loc 1 60 0
  15               		.cfi_startproc
  16               	.LVL0:
  17 0000 CF93      		push r28
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 28, -2
  21               	/* prologue: function */
  22               	/* frame size = 0 */
  23               	/* stack size = 1 */
  24               	.L__stack_usage = 1
  25 0002 C82F      		mov r28,r24
  61:main.c        ****   if (c == '\n') {
  26               		.loc 1 61 0
  27 0004 8A30      		cpi r24,lo8(10)
  28 0006 01F4      		brne .L3
  62:main.c        ****     uart_putchar('\r', stream);
  29               		.loc 1 62 0
  30 0008 8DE0      		ldi r24,lo8(13)
  31               	.LVL1:
  32 000a 0E94 0000 		call uart_putchar
  33               	.LVL2:
  34               	.L3:
  63:main.c        ****   }
  64:main.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
  35               		.loc 1 64 0 discriminator 1
  36 000e 8091 C000 		lds r24,192
  37 0012 85FF      		sbrs r24,5
  38 0014 00C0      		rjmp .L3
  65:main.c        ****   UDR0 = c;
  39               		.loc 1 65 0
  40 0016 C093 C600 		sts 198,r28
  66:main.c        ****   return 0;
  67:main.c        **** }
  41               		.loc 1 67 0
  42 001a 90E0      		ldi r25,0
  43 001c 80E0      		ldi r24,0
  44               	/* epilogue start */
  45 001e CF91      		pop r28
  46               	.LVL3:
  47 0020 0895      		ret
  48               		.cfi_endproc
  49               	.LFE12:
  51               	.global	uart_init
  53               	uart_init:
  54               	.LFB11:
  45:main.c        ****     UBRR0H = UBRRH_VALUE;
  55               		.loc 1 45 0
  56               		.cfi_startproc
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 0 */
  60               	.L__stack_usage = 0
  46:main.c        ****     UBRR0L = UBRRL_VALUE;
  61               		.loc 1 46 0
  62 0022 1092 C500 		sts 197,__zero_reg__
  47:main.c        ****     
  63               		.loc 1 47 0
  64 0026 80E1      		ldi r24,lo8(16)
  65 0028 8093 C400 		sts 196,r24
  50:main.c        **** #else
  66               		.loc 1 50 0
  67 002c E0EC      		ldi r30,lo8(-64)
  68 002e F0E0      		ldi r31,0
  69 0030 8081      		ld r24,Z
  70 0032 8260      		ori r24,lo8(2)
  71 0034 8083      		st Z,r24
  55:main.c        ****     UCSR0B = _BV(RXEN0) | _BV(TXEN0);   // Enable RX and TX
  72               		.loc 1 55 0
  73 0036 86E0      		ldi r24,lo8(6)
  74 0038 8093 C200 		sts 194,r24
  56:main.c        **** }
  75               		.loc 1 56 0
  76 003c 88E1      		ldi r24,lo8(24)
  77 003e 8093 C100 		sts 193,r24
  78               	/* epilogue start */
  57:main.c        **** 
  79               		.loc 1 57 0
  80 0042 0895      		ret
  81               		.cfi_endproc
  82               	.LFE11:
  84               	.global	enableParkMode
  86               	enableParkMode:
  87               	.LFB13:
  68:main.c        **** 
  69:main.c        **** // Setup UART stream
  70:main.c        **** static FILE uart_output = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);
  71:main.c        **** 
  72:main.c        **** // Enable Park Mode
  73:main.c        **** void enableParkMode(void) {
  88               		.loc 1 73 0
  89               		.cfi_startproc
  90               	/* prologue: function */
  91               	/* frame size = 0 */
  92               	/* stack size = 0 */
  93               	.L__stack_usage = 0
  74:main.c        ****   PORTC &= ~_BV(PORTC0); // digitalWrite(PARK_FRONT, LOW);
  94               		.loc 1 74 0
  95 0044 4098      		cbi 0x8,0
  75:main.c        ****   PORTC &= ~_BV(PORTC1); // digitalWrite(PARK_RIGHT, LOW);
  96               		.loc 1 75 0
  97 0046 4198      		cbi 0x8,1
  76:main.c        ****   PORTC &= ~_BV(PORTC2); // digitalWrite(PARK_LEFT, LOW);
  98               		.loc 1 76 0
  99 0048 4298      		cbi 0x8,2
  77:main.c        ****   PORTC &= ~_BV(PORTC3); // digitalWrite(PARK_REAR, LOW);
 100               		.loc 1 77 0
 101 004a 4398      		cbi 0x8,3
  78:main.c        ****   // Turn PARK_STATUS LED ON
  79:main.c        ****   PORTC |= _BV(PORTC4); // digitalWrite(PARK_STATUS, HIGH);
 102               		.loc 1 79 0
 103 004c 449A      		sbi 0x8,4
  80:main.c        ****   puts_P(enablePark); // Print park mode status message
 104               		.loc 1 80 0
 105 004e 80E0      		ldi r24,lo8(enablePark)
 106 0050 90E0      		ldi r25,hi8(enablePark)
 107 0052 0E94 0000 		call puts_P
 108               	.LVL4:
 109               	.LBB8:
 110               	.LBB9:
 111               		.file 2 "/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h"
   1:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    All rights reserved.
   5:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
   6:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
   9:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  12:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****      distribution.
  16:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  17:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  21:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  33:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** /* $Id$ */
  34:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  35:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  38:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #  endif
  42:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  44:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #include <math.h>
  47:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  48:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** /** \file */
  49:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     \code
  51:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     \endcode
  55:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  56:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     used.
  60:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  61:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  70:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     routines linked into the application.
  78:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  79:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  83:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** */
  84:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  85:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #endif
  89:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  90:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     \def F_CPU
  95:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
  97:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 103:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****     integer value.
 107:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****  */
 108:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #endif
 110:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 111:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #endif
 114:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 115:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #  include <math.h>
 119:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #endif
 120:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 121:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** /**
 122:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 124:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 126:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 129:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 131:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 137:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 142:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    microseconds of delay.
 146:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 147:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    respectively.
 151:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 152:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    \note
 153:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 154:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 164:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****  */
 165:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** void
 166:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** {
 168:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 	double __tmp ;
 169:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 176:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 179:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 182:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 	#else
 183:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 		//round up by default
 184:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 	#endif
 186:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 
 187:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 112               		.loc 2 187 0
 113 0056 8FE3      		ldi r24,lo8(-25537)
 114 0058 9CE9      		ldi r25,hi8(-25537)
 115 005a 0197      	1:	sbiw r24,1
 116 005c 01F4      		brne 1b
 117 005e 00C0      		rjmp .
 118 0060 0000      		nop
 119               	.LVL5:
 120               	/* epilogue start */
 121               	.LBE9:
 122               	.LBE8:
  81:main.c        ****   _delay_ms(SERIAL_DELAY); // Wait for serial output to finish
  82:main.c        **** }
 123               		.loc 1 82 0
 124 0062 0895      		ret
 125               		.cfi_endproc
 126               	.LFE13:
 128               	.global	disableParkMode
 130               	disableParkMode:
 131               	.LFB14:
  83:main.c        **** 
  84:main.c        **** // Disable Park Mode
  85:main.c        **** void disableParkMode(void) {
 132               		.loc 1 85 0
 133               		.cfi_startproc
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
  86:main.c        ****   PORTC |= _BV(PORTC0); // digitalWrite(PARK_FRONT, HIGH);
 138               		.loc 1 86 0
 139 0064 409A      		sbi 0x8,0
  87:main.c        ****   PORTC |= _BV(PORTC1); // digitalWrite(PARK_RIGHT, HIGH);
 140               		.loc 1 87 0
 141 0066 419A      		sbi 0x8,1
  88:main.c        ****   PORTC |= _BV(PORTC2); // digitalWrite(PARK_LEFT, HIGH);
 142               		.loc 1 88 0
 143 0068 429A      		sbi 0x8,2
  89:main.c        ****   PORTC |= _BV(PORTC3); // digitalWrite(PARK_REAR, HIGH);
 144               		.loc 1 89 0
 145 006a 439A      		sbi 0x8,3
  90:main.c        ****   // Turn PARK_STATUS LED OFF
  91:main.c        ****   PORTC &= ~_BV(PORTC4); // digitalWrite(PARK_STATUS, LOW);
 146               		.loc 1 91 0
 147 006c 4498      		cbi 0x8,4
  92:main.c        ****   puts_P(disablePark); // Print park mode status message
 148               		.loc 1 92 0
 149 006e 80E0      		ldi r24,lo8(disablePark)
 150 0070 90E0      		ldi r25,hi8(disablePark)
 151 0072 0E94 0000 		call puts_P
 152               	.LVL6:
 153               	.LBB10:
 154               	.LBB11:
 155               		.loc 2 187 0
 156 0076 8FE3      		ldi r24,lo8(-25537)
 157 0078 9CE9      		ldi r25,hi8(-25537)
 158 007a 0197      	1:	sbiw r24,1
 159 007c 01F4      		brne 1b
 160 007e 00C0      		rjmp .
 161 0080 0000      		nop
 162               	.LVL7:
 163               	/* epilogue start */
 164               	.LBE11:
 165               	.LBE10:
  93:main.c        ****   _delay_ms(SERIAL_DELAY); // Wait for serial output to finish
  94:main.c        **** }
 166               		.loc 1 94 0
 167 0082 0895      		ret
 168               		.cfi_endproc
 169               	.LFE14:
 171               		.section	.text.startup,"ax",@progbits
 172               	.global	main
 174               	main:
 175               	.LFB15:
  95:main.c        **** 
  96:main.c        **** // Main loop
  97:main.c        **** int main(void) {
 176               		.loc 1 97 0
 177               		.cfi_startproc
 178               	/* prologue: function */
 179               	/* frame size = 0 */
 180               	/* stack size = 0 */
 181               	.L__stack_usage = 0
  98:main.c        ****   // Configure IO
  99:main.c        ****   DDRC |= _BV(DDC0);    // pinMode(PARK_FRONT, OUTPUT);
 182               		.loc 1 99 0
 183 0000 389A      		sbi 0x7,0
 100:main.c        ****   DDRC |= _BV(DDC1);    // pinMode(PARK_RIGHT, OUTPUT);
 184               		.loc 1 100 0
 185 0002 399A      		sbi 0x7,1
 101:main.c        ****   DDRC |= _BV(DDC2);    // pinMode(PARK_LEFT, OUTPUT);
 186               		.loc 1 101 0
 187 0004 3A9A      		sbi 0x7,2
 102:main.c        ****   DDRC |= _BV(DDC3);    // pinMode(PARK_REAR, OUTPUT);
 188               		.loc 1 102 0
 189 0006 3B9A      		sbi 0x7,3
 103:main.c        ****   DDRC |= _BV(DDC4);    // pinMode(PARK_STATUS, OUTPUT);
 190               		.loc 1 103 0
 191 0008 3C9A      		sbi 0x7,4
 104:main.c        ****   DDRB |= _BV(DDB5);    // pinMode(POWER_STATUS, OUTPUT);
 192               		.loc 1 104 0
 193 000a 259A      		sbi 0x4,5
 105:main.c        ****   DDRD &= ~_BV(DDD2);   // Clear the PD2 pin
 194               		.loc 1 105 0
 195 000c 5298      		cbi 0xa,2
 106:main.c        ****   PORTD |= _BV(PORTD2); // Enable PD2 internal pull-up
 196               		.loc 1 106 0
 197 000e 5A9A      		sbi 0xb,2
 107:main.c        ****   
 108:main.c        ****   // UART setup
 109:main.c        ****   uart_init();
 198               		.loc 1 109 0
 199 0010 0E94 0000 		call uart_init
 200               	.LVL8:
 110:main.c        ****   stdout = &uart_output;
 201               		.loc 1 110 0
 202 0014 80E0      		ldi r24,lo8(uart_output)
 203 0016 90E0      		ldi r25,hi8(uart_output)
 204 0018 9093 0000 		sts __iob+2+1,r25
 205 001c 8093 0000 		sts __iob+2,r24
 111:main.c        **** 
 112:main.c        ****   // Turn POWER_STATUS LED ON
 113:main.c        ****   PORTB |= _BV(PORTB5); // digitalWrite(POWER_STATUS, HIGH);
 206               		.loc 1 113 0
 207 0020 2D9A      		sbi 0x5,5
 114:main.c        ****   puts_P(status); // Print system status message
 208               		.loc 1 114 0
 209 0022 80E0      		ldi r24,lo8(status)
 210 0024 90E0      		ldi r25,hi8(status)
 211 0026 0E94 0000 		call puts_P
 212               	.LVL9:
 213               	.LBB12:
 214               	.LBB13:
 215               		.loc 2 187 0
 216 002a 8FE3      		ldi r24,lo8(-25537)
 217 002c 9CE9      		ldi r25,hi8(-25537)
 218 002e 0197      	1:	sbiw r24,1
 219 0030 01F4      		brne 1b
 220 0032 00C0      		rjmp .
 221 0034 0000      		nop
 222               	.LVL10:
 223               	.LBE13:
 224               	.LBE12:
 115:main.c        ****   _delay_ms(SERIAL_DELAY); // Wait for serial output to finish
 116:main.c        **** 
 117:main.c        ****   // Enable park mode as default state
 118:main.c        ****   disableParkMode();
 225               		.loc 1 118 0
 226 0036 0E94 0000 		call disableParkMode
 227               	.LVL11:
 119:main.c        **** 
 120:main.c        ****   // Loop
 121:main.c        ****   while(1) {
 122:main.c        ****     // Power saving
 123:main.c        ****     power_adc_disable ();
 124:main.c        ****     power_spi_disable();
 125:main.c        ****     power_twi_disable();
 126:main.c        ****     power_timer1_disable();
 127:main.c        ****     power_timer2_disable();
 128:main.c        **** 
 129:main.c        ****     // Configure sleep
 130:main.c        ****     set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 131:main.c        ****     sleep_enable();
 132:main.c        **** 
 133:main.c        ****     // Do not interrupt before to sleep or ISR will detach interrupts won't wake.
 134:main.c        ****     cli();
 135:main.c        **** 
 136:main.c        ****     // Interrupt init
 137:main.c        ****     // Enable Pin Change Interrupt on the PCINT18 pin using Pin Change Mask Register 2 (PCMSK2)
 138:main.c        ****     PCMSK2 |= _BV(PCINT18);
 139:main.c        ****     // Enable Pin Change Interrupt 2 using the Pin Change Interrupt Control Register (PCICR)
 140:main.c        ****     PCICR |= _BV(PCIE2);
 141:main.c        **** 
 142:main.c        ****     // Turn off brown-out enable in software
 143:main.c        ****     MCUCR = _BV(BODS) | _BV(BODSE);
 228               		.loc 1 143 0
 229 003a 20E6      		ldi r18,lo8(96)
 144:main.c        ****     MCUCR = _BV(BODS);
 230               		.loc 1 144 0
 231 003c 90E4      		ldi r25,lo8(64)
 232               	.L10:
 123:main.c        ****     power_spi_disable();
 233               		.loc 1 123 0 discriminator 1
 234 003e 8091 6400 		lds r24,100
 235 0042 8160      		ori r24,lo8(1)
 236 0044 8093 6400 		sts 100,r24
 124:main.c        ****     power_twi_disable();
 237               		.loc 1 124 0 discriminator 1
 238 0048 8091 6400 		lds r24,100
 239 004c 8460      		ori r24,lo8(4)
 240 004e 8093 6400 		sts 100,r24
 125:main.c        ****     power_timer1_disable();
 241               		.loc 1 125 0 discriminator 1
 242 0052 8091 6400 		lds r24,100
 243 0056 8068      		ori r24,lo8(-128)
 244 0058 8093 6400 		sts 100,r24
 126:main.c        ****     power_timer2_disable();
 245               		.loc 1 126 0 discriminator 1
 246 005c 8091 6400 		lds r24,100
 247 0060 8860      		ori r24,lo8(8)
 248 0062 8093 6400 		sts 100,r24
 127:main.c        **** 
 249               		.loc 1 127 0 discriminator 1
 250 0066 8091 6400 		lds r24,100
 251 006a 8064      		ori r24,lo8(64)
 252 006c 8093 6400 		sts 100,r24
 130:main.c        ****     sleep_enable();
 253               		.loc 1 130 0 discriminator 1
 254 0070 83B7      		in r24,0x33
 255 0072 817F      		andi r24,lo8(-15)
 256 0074 8460      		ori r24,lo8(4)
 257 0076 83BF      		out 0x33,r24
 131:main.c        **** 
 258               		.loc 1 131 0 discriminator 1
 259 0078 83B7      		in r24,0x33
 260 007a 8160      		ori r24,lo8(1)
 261 007c 83BF      		out 0x33,r24
 134:main.c        **** 
 262               		.loc 1 134 0 discriminator 1
 263               	/* #APP */
 264               	 ;  134 "main.c" 1
 265 007e F894      		cli
 266               	 ;  0 "" 2
 138:main.c        ****     // Enable Pin Change Interrupt 2 using the Pin Change Interrupt Control Register (PCICR)
 267               		.loc 1 138 0 discriminator 1
 268               	/* #NOAPP */
 269 0080 8091 6D00 		lds r24,109
 270 0084 8460      		ori r24,lo8(4)
 271 0086 8093 6D00 		sts 109,r24
 140:main.c        **** 
 272               		.loc 1 140 0 discriminator 1
 273 008a 8091 6800 		lds r24,104
 274 008e 8460      		ori r24,lo8(4)
 275 0090 8093 6800 		sts 104,r24
 143:main.c        ****     MCUCR = _BV(BODS);
 276               		.loc 1 143 0 discriminator 1
 277 0094 25BF      		out 0x35,r18
 278               		.loc 1 144 0 discriminator 1
 279 0096 95BF      		out 0x35,r25
 145:main.c        **** 
 146:main.c        ****     // Enable interrupts
 147:main.c        ****     sei();
 280               		.loc 1 147 0 discriminator 1
 281               	/* #APP */
 282               	 ;  147 "main.c" 1
 283 0098 7894      		sei
 284               	 ;  0 "" 2
 148:main.c        ****     // Guaranteed sleep_cpu call will be done as CPU executes next instruction after interrupts ena
 149:main.c        ****     sleep_cpu();
 285               		.loc 1 149 0 discriminator 1
 286               	 ;  149 "main.c" 1
 287 009a 8895      		sleep
 288               		
 289               	 ;  0 "" 2
 290               	/* #NOAPP */
 291 009c 00C0      		rjmp .L10
 292               		.cfi_endproc
 293               	.LFE15:
 295               		.text
 296               	.global	__vector_5
 298               	__vector_5:
 299               	.LFB16:
 150:main.c        ****   }
 151:main.c        **** 
 152:main.c        ****   return 0;
 153:main.c        **** }
 154:main.c        **** 
 155:main.c        **** ISR(PCINT2_vect)
 156:main.c        **** {
 300               		.loc 1 156 0
 301               		.cfi_startproc
 302 0084 1F92      		push r1
 303               	.LCFI1:
 304               		.cfi_def_cfa_offset 3
 305               		.cfi_offset 1, -2
 306 0086 0F92      		push r0
 307               	.LCFI2:
 308               		.cfi_def_cfa_offset 4
 309               		.cfi_offset 0, -3
 310 0088 0FB6      		in r0,__SREG__
 311 008a 0F92      		push r0
 312 008c 1124      		clr __zero_reg__
 313 008e 2F93      		push r18
 314               	.LCFI3:
 315               		.cfi_def_cfa_offset 5
 316               		.cfi_offset 18, -4
 317 0090 3F93      		push r19
 318               	.LCFI4:
 319               		.cfi_def_cfa_offset 6
 320               		.cfi_offset 19, -5
 321 0092 4F93      		push r20
 322               	.LCFI5:
 323               		.cfi_def_cfa_offset 7
 324               		.cfi_offset 20, -6
 325 0094 5F93      		push r21
 326               	.LCFI6:
 327               		.cfi_def_cfa_offset 8
 328               		.cfi_offset 21, -7
 329 0096 6F93      		push r22
 330               	.LCFI7:
 331               		.cfi_def_cfa_offset 9
 332               		.cfi_offset 22, -8
 333 0098 7F93      		push r23
 334               	.LCFI8:
 335               		.cfi_def_cfa_offset 10
 336               		.cfi_offset 23, -9
 337 009a 8F93      		push r24
 338               	.LCFI9:
 339               		.cfi_def_cfa_offset 11
 340               		.cfi_offset 24, -10
 341 009c 9F93      		push r25
 342               	.LCFI10:
 343               		.cfi_def_cfa_offset 12
 344               		.cfi_offset 25, -11
 345 009e AF93      		push r26
 346               	.LCFI11:
 347               		.cfi_def_cfa_offset 13
 348               		.cfi_offset 26, -12
 349 00a0 BF93      		push r27
 350               	.LCFI12:
 351               		.cfi_def_cfa_offset 14
 352               		.cfi_offset 27, -13
 353 00a2 EF93      		push r30
 354               	.LCFI13:
 355               		.cfi_def_cfa_offset 15
 356               		.cfi_offset 30, -14
 357 00a4 FF93      		push r31
 358               	.LCFI14:
 359               		.cfi_def_cfa_offset 16
 360               		.cfi_offset 31, -15
 361               	/* prologue: Signal */
 362               	/* frame size = 0 */
 363               	/* stack size = 15 */
 364               	.L__stack_usage = 15
 157:main.c        ****   // Cancel sleep as a precaution
 158:main.c        ****   sleep_disable();
 365               		.loc 1 158 0
 366 00a6 83B7      		in r24,0x33
 367 00a8 8E7F      		andi r24,lo8(-2)
 368 00aa 83BF      		out 0x33,r24
 159:main.c        ****   // Disable Pin Change Interrupt 2 while we do stuff
 160:main.c        ****   PCICR &= ~_BV(PCIE2);
 369               		.loc 1 160 0
 370 00ac 8091 6800 		lds r24,104
 371 00b0 8B7F      		andi r24,lo8(-5)
 372 00b2 8093 6800 		sts 104,r24
 161:main.c        ****   // Read PD2 using the Port D Pin Input Register (PIND)
 162:main.c        ****   if (PIND & _BV(PIND2)) { // PD2 is HIGH
 373               		.loc 1 162 0
 374 00b6 4A9B      		sbis 0x9,2
 375 00b8 00C0      		rjmp .L12
 163:main.c        ****     enableParkMode();
 376               		.loc 1 163 0
 377 00ba 0E94 0000 		call enableParkMode
 378               	.LVL12:
 379               	.L11:
 380               	/* epilogue start */
 164:main.c        ****   } else { // PD2 is LOW
 165:main.c        ****     disableParkMode();
 166:main.c        ****   }
 167:main.c        **** }
 381               		.loc 1 167 0
 382 00be FF91      		pop r31
 383 00c0 EF91      		pop r30
 384 00c2 BF91      		pop r27
 385 00c4 AF91      		pop r26
 386 00c6 9F91      		pop r25
 387 00c8 8F91      		pop r24
 388 00ca 7F91      		pop r23
 389 00cc 6F91      		pop r22
 390 00ce 5F91      		pop r21
 391 00d0 4F91      		pop r20
 392 00d2 3F91      		pop r19
 393 00d4 2F91      		pop r18
 394 00d6 0F90      		pop r0
 395 00d8 0FBE      		out __SREG__,r0
 396 00da 0F90      		pop r0
 397 00dc 1F90      		pop r1
 398 00de 1895      		reti
 399               	.L12:
 165:main.c        ****   }
 400               		.loc 1 165 0
 401 00e0 0E94 0000 		call disableParkMode
 402               	.LVL13:
 403               		.loc 1 167 0
 404 00e4 00C0      		rjmp .L11
 405               		.cfi_endproc
 406               	.LFE16:
 408               		.data
 411               	uart_output:
 412 0000 0000 00   		.zero	3
 413 0003 02        		.byte	2
 414 0004 0000 0000 		.zero	4
 415 0008 0000      		.word	gs(uart_putchar)
 416 000a 0000      		.word	0
 417 000c 0000      		.word	0
 418               	.global	disablePark
 419               		.section	.progmem.data,"a",@progbits
 422               	disablePark:
 423 0000 5061 726B 		.string	"Park Mode: Disabled"
 423      204D 6F64 
 423      653A 2044 
 423      6973 6162 
 423      6C65 6400 
 424               	.global	enablePark
 427               	enablePark:
 428 0014 5061 726B 		.string	"Park Mode: Enabled"
 428      204D 6F64 
 428      653A 2045 
 428      6E61 626C 
 428      6564 00
 429               	.global	status
 432               	status:
 433 0027 5379 7374 		.string	"System Status: OK"
 433      656D 2053 
 433      7461 7475 
 433      733A 204F 
 433      4B00 
 434               		.text
 435               	.Letext0:
 436               		.file 3 "/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/stdint.h"
 437               		.file 4 "/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:4      *ABS*:000000000000003f __SREG__
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:11     .text:0000000000000000 uart_putchar
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:53     .text:0000000000000022 uart_init
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:86     .text:0000000000000044 enableParkMode
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:427    .progmem.data:0000000000000014 enablePark
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:130    .text:0000000000000064 disableParkMode
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:422    .progmem.data:0000000000000000 disablePark
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:174    .text.startup:0000000000000000 main
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:411    .data:0000000000000000 uart_output
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:432    .progmem.data:0000000000000027 status
/var/folders/cn/ghdhbyrd5xx6g4crh7qghxx80000gn/T//cc0XVFmo.s:298    .text:0000000000000084 __vector_5

UNDEFINED SYMBOLS
puts_P
__iob
__do_copy_data
